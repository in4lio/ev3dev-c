($!
     ____ __     ____   ___    ____ __         (((((()
    | |_  \ \  /   ) ) | |  ) | |_  \ \  /  \(@)- /
    |_|__  \_\/  __)_) |_|_/  |_|__  \_\/   /(@)- \
                                               ((())))

($import "app.yu")
($TITLE,,ev3dev file operations.)

($import stdlib)
($import h)

($implement-named)

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include "modp_numtoa.h"
#include "ev3.h"

/**
 *  \addtogroup ev3dev
 *  \{
 */

// EV3 BRICK /////////////////////////////////////
#ifdef __ARM_ARCH_4T__

#include <sys/types.h>
#include <dirent.h>

bool ev3_init( void )
{
	return ( true );
}

void ev3_uninit( void )
{

}

size_t ev3_write_binary( const char *fn, void *data, size_t sz )
{
	FILE *f;
	size_t result;

	f = fopen( fn, "w" );
	if ( f == NULL ) return ( 0 );

	result = fwrite( data, 1, sz, f );
	fclose( f );
	return ( result );
}

size_t ev3_read_binary( const char *fn, void *buf, size_t sz )
{
	FILE *f;
	size_t result;

	f = fopen( fn, "r" );
	if ( f == NULL ) return ( 0 );

	result = fread( buf, 1, sz, f );
	fclose( f );
	return ( result );
}

static size_t __ev3_listdir( char *fn, void *buf, size_t sz )
{
	DIR *d;
	struct dirent *de;
	char *p;

	d = opendir( fn );
	if ( d == NULL ) return ( 0 );

	p = buf;
	while (( de = readdir( d ))) {
		size_t l = strlen( de->d_name ) + 1;
		if ( sz > l ) {
			sz -= l;
			memcpy( p, de->d_name, l - 1 );
			p[ l - 1 ] = ' ';
			p += l;
		}
	}
	closedir( d );
	return (( void *) p - buf );
}

bool ev3_poweroff( void )
{
	system( "shutdown -h now" );
	return ( true );
}

// CLIENT ////////////////////////////////////////
#else

#include "ev3_link.h"

// WIN32 /////////////////////////////////////////
#ifdef __WIN32__

#include <windows.h>

// UNIX //////////////////////////////////////////
#else

#include <unistd.h>
#define Sleep( msec ) usleep(( msec ) * 1000 )

//////////////////////////////////////////////////
#endif

bool ev3_init( void )
{
	if ( udp_ev3_open( ev3_brick_addr, ev3_brick_port ) == EOF ) return ( false );

	if ( !ev3_brick_addr ) {
		while ( !udp_ev3_catch_address()) Sleep( 1000 );
	}
	return ( true );
}

void ev3_uninit( void )
{
	udp_ev3_close();
}

size_t ev3_write_binary( const char *fn, void *data, size_t sz )
{
	return udp_ev3_write(( char *) fn, data, sz );
}

size_t ev3_read_binary( const char *fn, void *buf, size_t sz )
{
	return udp_ev3_read(( char *) fn, buf, sz );
}

static size_t __ev3_listdir( char *fn, char *buf, size_t sz )
{
	return udp_ev3_listdir( fn, buf, sz );
}

bool ev3_poweroff( void )
{
	return udp_ev3_poweroff();
}

//////////////////////////////////////////////////
#endif

size_t ev3_write( const char *fn, char *value )
{
	return ev3_write_binary( fn, value, strlen( value ));
}

size_t ev3_write_int( const char *fn, int value )
{
	char s[ ($inc ($len ($str ($INT_MIN)))) ];

	modp_itoa10( value, s );
	return ev3_write( fn, s );
}

size_t ev3_write_dword( const char *fn, uint32_t value )
{
	char s[ ($len ($str ($INT_MIN))) ];

	modp_uitoa10( value, s );
	return ev3_write( fn, s );
}

size_t ev3_write_float( const char *fn, float value )
{
	char s[ 32 ];

	modp_dtoa2( value, s, 4 );
	return ev3_write( fn, s );
}

size_t ev3_write_bool( const char *fn, bool value )
{
	return ev3_write_binary( fn, ( value ) ? "1" : "0", 1 );
}

size_t ev3_write_char_array( const char *fn, char *value )
{
	return ev3_write( fn, value );
}

size_t ev3_write_byte_array( const char *fn, uint8_t *value, size_t sz )
{
	return ev3_write_binary( fn, value, sz );
}

size_t ev3_read( const char *fn, char *buf, size_t sz )
{
	size_t c;

	if ( sz < 1 ) return ( 0 );

	c = ev3_read_binary( fn, buf, sz );
	buf[ c - 1 ] = '\x00';
	return ( c );
}

size_t ev3_read_int( const char *fn, int *value )
{
	char buf[ ($inc ($len ($str ($INT_MIN)))) ];
	char *end;

	if ( ev3_read( fn, buf, sizeof( buf ))) {
		*value = strtol( buf, &end, 0 );
		if ( *end ) return ( 0 );

		return ( sizeof( int ));
	}
	return ( 0 );
}

size_t ev3_read_dword( const char *fn, uint32_t *value )
{
	char buf[ ($len ($str ($INT_MIN))) ];
	char *end;

	if ( ev3_read( fn, buf, sizeof( buf ))) {
		*value = strtoul( buf, &end, 0 );
		if ( *end ) return ( 0 );

		return ( sizeof( uint32_t ));
	}
	return ( 0 );
}

size_t ev3_read_float( const char *fn, float *value )
{
	char buf[ 16 ];
	char *end;

	if ( ev3_read( fn, buf, sizeof( buf ))) {
		*value = ( float ) strtod( buf, &end );
		if ( *end ) return ( 0 );

		return ( sizeof( float ));
	}
	return ( 0 );
}

size_t ev3_read_bool( const char *fn, bool *value )
{
	int _int;
	if ( ev3_read_int( fn, &_int )) {
		*value = !!_int;

		return ( sizeof( bool ));
	}
	return ( 0 );
}

size_t ev3_read_char_array( const char *fn, char *buf, size_t sz )
{
	return ev3_read( fn, buf, sz );
}

size_t ev3_read_byte_array( const char *fn, uint8_t *buf, size_t sz )
{
	return ev3_read_binary( fn, buf, sz );
}

size_t ev3_listdir( const char *fn, char *buf, size_t sz )
{
	size_t c;

	if ( sz < 1 ) return ( 0 );

	c = __ev3_listdir(( char *) fn, buf, sz );
	buf[ c - 1 ] = '\x00';
	return ( c );
}

/** \} */
