
/*  nxt_input_mux.c was generated by yup.py (yupp) 0.7b7
    out of nxt_input_mux.yu-c at 2014-11-26 12:58
 *//**
 *  \file  nxt_input_mux.c (nxt_input_mux.yu-c)
 *  \brief  NXT Multiplexer Input Ports.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define NXT_INPUT_MUX_IMPLEMENT

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "ev3.h"
#include "ev3_port.h"
#include "ev3_input.h"
#include "nxt_input_mux.h"

#define PORT_PATH_LEN  25  /* "/sys/bus/legoev3/devices/" */
#define PORT_NAME_LEN  8  /* "in0:mux0" */

const char *nxt_input_mux_name( uint8_t port, uint8_t extport )
{
	switch ( port ) {
	case INPUT_1:
		switch ( extport ) {
		case INPUT_MUX__NONE_:
			return "in1";
		case INPUT_MUX_1:
			return "in1:mux1";
		case INPUT_MUX_2:
			return "in1:mux2";
		case INPUT_MUX_3:
			return "in1:mux3";
		case INPUT_MUX_4:
			return "in1:mux4";

		}
	case INPUT_2:
		switch ( extport ) {
		case INPUT_MUX__NONE_:
			return "in2";
		case INPUT_MUX_1:
			return "in2:mux1";
		case INPUT_MUX_2:
			return "in2:mux2";
		case INPUT_MUX_3:
			return "in2:mux3";
		case INPUT_MUX_4:
			return "in2:mux4";

		}
	case INPUT_3:
		switch ( extport ) {
		case INPUT_MUX__NONE_:
			return "in3";
		case INPUT_MUX_1:
			return "in3:mux1";
		case INPUT_MUX_2:
			return "in3:mux2";
		case INPUT_MUX_3:
			return "in3:mux3";
		case INPUT_MUX_4:
			return "in3:mux4";

		}
	case INPUT_4:
		switch ( extport ) {
		case INPUT_MUX__NONE_:
			return "in4";
		case INPUT_MUX_1:
			return "in4:mux1";
		case INPUT_MUX_2:
			return "in4:mux2";
		case INPUT_MUX_3:
			return "in4:mux3";
		case INPUT_MUX_4:
			return "in4:mux4";

		}

	}
	return STR_unknown_;
}

uint8_t nxt_input_mux_inx( const char *name, uint8_t *extport )
{
	uint8_t port = EV3_PORT__NONE_;

	*extport = INPUT_MUX__NONE_;
	if ( strlen( name ) != PORT_NAME_LEN ) return ( EV3_PORT__NONE_ );

	if ( strncmp( name, "in1", 3 ) == 0 ) port = INPUT_1;
	if ( strncmp( name, "in2", 3 ) == 0 ) port = INPUT_2;
	if ( strncmp( name, "in3", 3 ) == 0 ) port = INPUT_3;
	if ( strncmp( name, "in4", 3 ) == 0 ) port = INPUT_4;

	if ( port == EV3_PORT__NONE_ ) return ( EV3_PORT__NONE_ );

	name += 4;
	if ( strncmp( name, "mux1", 4 ) == 0 ) *extport = INPUT_MUX_1;
	if ( strncmp( name, "mux2", 4 ) == 0 ) *extport = INPUT_MUX_2;
	if ( strncmp( name, "mux3", 4 ) == 0 ) *extport = INPUT_MUX_3;
	if ( strncmp( name, "mux4", 4 ) == 0 ) *extport = INPUT_MUX_4;

	if ( *extport == INPUT_MUX__NONE_ ) return ( EV3_PORT__NONE_ );

	return ( port );
}

size_t get_input_mux_mode( uint8_t port, uint8_t extport, char *buf, size_t sz )
{
	char s[ 64 ] = "/sys/bus/legoev3/devices" "/";

	if (( port - INPUT__BASE_ >= INPUT__COUNT_ ) || ( extport - INPUT_MUX__BASE_ >= INPUT_MUX__COUNT_ )) return ( 0 );

	strcpy( s + PORT_PATH_LEN, nxt_input_mux_name( port, extport ));
	strcpy( s + PORT_PATH_LEN + PORT_NAME_LEN, "/" "mode" );
	return ev3_read_char_array( s, buf, sz );
}

size_t set_input_mux_mode( uint8_t port, uint8_t extport, char *value )
{
	char s[ 64 ] = "/sys/bus/legoev3/devices" "/";

	if (( port - INPUT__BASE_ >= INPUT__COUNT_ ) || ( extport - INPUT_MUX__BASE_ >= INPUT_MUX__COUNT_ )) return ( 0 );

	strcpy( s + PORT_PATH_LEN, nxt_input_mux_name( port, extport ));
	strcpy( s + PORT_PATH_LEN + PORT_NAME_LEN, "/" "mode" );
	return ev3_write_char_array( s, value );
}

size_t get_input_mux_modes( uint8_t port, uint8_t extport, char *buf, size_t sz )
{
	char s[ 64 ] = "/sys/bus/legoev3/devices" "/";

	if (( port - INPUT__BASE_ >= INPUT__COUNT_ ) || ( extport - INPUT_MUX__BASE_ >= INPUT_MUX__COUNT_ )) return ( 0 );

	strcpy( s + PORT_PATH_LEN, nxt_input_mux_name( port, extport ));
	strcpy( s + PORT_PATH_LEN + PORT_NAME_LEN, "/" "modes" );
	return ev3_read_char_array( s, buf, sz );
}

const char *nxt_input_mux_mode( uint8_t mode_inx )
{
	switch ( mode_inx ) {
	case INPUT_MUX_ANALOG:
		return "analog";
	case INPUT_MUX_I2C:
		return "i2c";

	}
	return STR_unknown_;
}

uint8_t get_input_mux_mode_inx( uint8_t port, uint8_t extport )
{
	char buf[ 64 ];

	if ( !get_input_mux_mode( port, extport, buf, sizeof( buf ))) return ( INPUT_MUX_MODE__COUNT_ );

	if ( strcmp( buf, "analog" ) == 0 ) return INPUT_MUX_ANALOG;
	if ( strcmp( buf, "i2c" ) == 0 ) return INPUT_MUX_I2C;

	return ( INPUT_MUX_MODE__COUNT_ );
}

size_t set_input_mux_mode_inx( uint8_t port, uint8_t extport, uint8_t mode_inx )
{
	return set_input_mux_mode( port, extport, ( char* ) nxt_input_mux_mode( mode_inx ));
}
