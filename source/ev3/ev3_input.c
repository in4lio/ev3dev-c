
/*  ev3_input.c was generated by yup.py (yupp) 0.7b6
    out of ev3_input.yu-c at 2014-11-10 13:55
 *//**
 *  \file  ev3_input.c (ev3_input.yu-c)
 *  \brief  EV3 input ports.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define EV3_INPUT_IMPLEMENT

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "ev3.h"
#include "ev3_port.h"
#include "ev3_input.h"

const char * const input_attr_mode[] = {
	"/sys/bus/legoev3/devices" "/" "in" "1" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "in" "2" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "in" "3" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "in" "4" "/" "mode",

};

const char * const input_attr_modes[] = {
	"/sys/bus/legoev3/devices" "/" "in" "1" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "in" "2" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "in" "3" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "in" "4" "/" "modes",

};

const char * const input_attr_pin1_mv[] = {
	"/sys/bus/legoev3/devices" "/" "in" "1" "/" "pin1_mv",
	"/sys/bus/legoev3/devices" "/" "in" "2" "/" "pin1_mv",
	"/sys/bus/legoev3/devices" "/" "in" "3" "/" "pin1_mv",
	"/sys/bus/legoev3/devices" "/" "in" "4" "/" "pin1_mv",

};

const char * const input_attr_pin6_mv[] = {
	"/sys/bus/legoev3/devices" "/" "in" "1" "/" "pin6_mv",
	"/sys/bus/legoev3/devices" "/" "in" "2" "/" "pin6_mv",
	"/sys/bus/legoev3/devices" "/" "in" "3" "/" "pin6_mv",
	"/sys/bus/legoev3/devices" "/" "in" "4" "/" "pin6_mv",

};

const char * const input_attr_state[] = {
	"/sys/bus/legoev3/devices" "/" "in" "1" "/" "state",
	"/sys/bus/legoev3/devices" "/" "in" "2" "/" "state",
	"/sys/bus/legoev3/devices" "/" "in" "3" "/" "state",
	"/sys/bus/legoev3/devices" "/" "in" "4" "/" "state",

};

size_t get_input_mode( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_mode[ n ], buf, sz );
}

size_t set_input_mode( uint8_t inx, char *value )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_write_char_array( input_attr_mode[ n ], value );
}

size_t get_input_modes( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_modes[ n ], buf, sz );
}

size_t get_input_pin1_mv( uint8_t inx, int *buf )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( input_attr_pin1_mv[ n ], buf );
}

size_t get_input_pin6_mv( uint8_t inx, int *buf )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( input_attr_pin6_mv[ n ], buf );
}

size_t get_input_state( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_state[ n ], buf, sz );
}

const char *ev3_input_mode( uint8_t mode_inx )
{
	switch ( mode_inx ) {
	case INPUT_AUTO:
		return "auto";
	case INPUT_EV3_ANALOG:
		return "ev3-analog";
	case INPUT_EV3_UART:
		return "ev3-uart";
	case INPUT_NXT_ANALOG:
		return "nxt-analog";
	case INPUT_NXT_COLOR:
		return "nxt-color";
	case INPUT_NXT_I2C:
		return "nxt-i2c";
	case INPUT_OTHER_UART:
		return "other-uart";
	case INPUT_RAW:
		return "raw";

	}
	return STR_unknown_;
}

uint8_t get_input_mode_inx( uint8_t inx )
{
	char buf[ 64 ];

	if ( !get_input_mode( inx, buf, sizeof( buf ))) return ( INPUT_MODE__COUNT_ );

	if ( strcmp( buf, "auto" ) == 0 ) return INPUT_AUTO;
	if ( strcmp( buf, "ev3-analog" ) == 0 ) return INPUT_EV3_ANALOG;
	if ( strcmp( buf, "ev3-uart" ) == 0 ) return INPUT_EV3_UART;
	if ( strcmp( buf, "nxt-analog" ) == 0 ) return INPUT_NXT_ANALOG;
	if ( strcmp( buf, "nxt-color" ) == 0 ) return INPUT_NXT_COLOR;
	if ( strcmp( buf, "nxt-i2c" ) == 0 ) return INPUT_NXT_I2C;
	if ( strcmp( buf, "other-uart" ) == 0 ) return INPUT_OTHER_UART;
	if ( strcmp( buf, "raw" ) == 0 ) return INPUT_RAW;

	return ( INPUT_MODE__COUNT_ );
}

size_t set_input_mode_inx( uint8_t inx, uint8_t mode_inx )
{
	return set_input_mode( inx, ( char* ) ev3_input_mode( mode_inx ));
}

uint8_t ev3_input_inx( const char *name, uint8_t *extport )
{
	uint32_t inx, extinx;
	char *s = ( char* ) name;

	*extport = EV3_PORT__NONE_;
	switch ( ev3_string_suffix( "in", &s, &inx )) {
	case 2:
		if ( ev3_string_suffix( "mux", &s, &extinx ) == 1 ) {
			*extport = ( uint8_t ) extinx;
		}
		/* fallthrough */
	case 1:
		if (( inx >= INPUT__BASE_) && ( inx < INPUT__BASE_ + INPUT__COUNT_ )) return ( inx );
	}
	return ( EV3_PORT__NONE_ );
}

const char *ev3_input_name( uint8_t inx, uint8_t extport )
{
	static char s[ 32 ];

	switch ( inx ) {
	case INPUT_1:
		switch ( extport ) {
		case EV3_PORT__NONE_:
			return "in1";
		case 1:
			return "in1mux1";
		case 2:
			return "in1mux2";
		case 3:
			return "in1mux3";
		case 4:
			return "in1mux4";

		default:
			snprintf( s, sizeof( s ), "in1mux%d", extport );
			return ( s );
		}
	case INPUT_2:
		switch ( extport ) {
		case EV3_PORT__NONE_:
			return "in2";
		case 1:
			return "in2mux1";
		case 2:
			return "in2mux2";
		case 3:
			return "in2mux3";
		case 4:
			return "in2mux4";

		default:
			snprintf( s, sizeof( s ), "in2mux%d", extport );
			return ( s );
		}
	case INPUT_3:
		switch ( extport ) {
		case EV3_PORT__NONE_:
			return "in3";
		case 1:
			return "in3mux1";
		case 2:
			return "in3mux2";
		case 3:
			return "in3mux3";
		case 4:
			return "in3mux4";

		default:
			snprintf( s, sizeof( s ), "in3mux%d", extport );
			return ( s );
		}
	case INPUT_4:
		switch ( extport ) {
		case EV3_PORT__NONE_:
			return "in4";
		case 1:
			return "in4mux1";
		case 2:
			return "in4mux2";
		case 3:
			return "in4mux3";
		case 4:
			return "in4mux4";

		default:
			snprintf( s, sizeof( s ), "in4mux%d", extport );
			return ( s );
		}

	}
	return STR_unknown_;
}
