
/*  ev3.i was generated by yup.py (yupp) 1.0c3
    out of ev3.yu-i 
 *//**
 *  \file  ev3.i (ev3.yu-i)
 *  \brief  SWIG interface file.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

%module ev3
%include "cstring.i"
%include "stdint.i"
%include "typemaps.i"

%{
#include "../source/ev3/ev3.h"
#include "../source/ev3/ev3_led.h"
#include "../source/ev3/ev3_light.h"
#include "../source/ev3/ev3_port.h"
#include "../source/ev3/ev3_sensor.h"
#include "../source/ev3/ev3_tacho.h"
#include "../source/ev3/ev3_dc.h"
#include "../source/ev3/ev3_servo.h"
#include "../source/ev3/brick.h"
%}

%define ALLOC_OUTPUT_BUFFER(TYPEMAP,MAX)
%typemap(in,noblock=1,numinputs=0) TYPEMAP (char temp[MAX+1]) {
  $1 =  temp;
}
%enddef

/* String buffer without size is passed only for getting a port name */
ALLOC_OUTPUT_BUFFER( char *buf, 64 );

/* Unfortunately incompatible with %typemap( default ) size_t sz { $1 = DEFAULT_BUF_SIZE; } */
%cstring_output_maxsize( char *buf, size_t sz );

%include "./platform.h"

#ifdef SWIGPERL
/* because of the problem with SWIG_From_bool on the brick... */
#define bool  int

#endif

%apply uint8_t *OUTPUT { uint8_t *sn };
%apply bool *OUTPUT { bool *buf };
%apply int *OUTPUT { int *buf };
%apply uint8_t *OUTPUT { uint8_t *buf };
%apply uint8_t *OUTPUT { byte *buf };
%apply uint32_t *OUTPUT { uint32_t *buf };
%apply uint32_t *OUTPUT { dword *buf };
%apply float *OUTPUT { float *buf };
%apply uint8_t *OUTPUT { FLAGS_T *flags };

%apply uint32_t { dword };
%apply uint8_t { byte };
%apply uint8_t { INX_T };
%apply uint8_t { FLAGS_T };
%apply uint8_t { POOL_T };

#ifdef SWIGRUBY
%typemap( out ) size_t, bool { $result = $1 ? Qtrue : Qfalse; };
%typemap( in ) bool { $1 = $input == Qtrue ? 1 : 0; };

#endif

%typemap( default ) uint8_t from { $1 = 0; };
%typemap( default ) dword defval { $1 = 0; };
%typemap( default ) float defval { $1 = 0.0; };
%typemap( default ) int defval { $1 = 0; };

/*
 *  ev3
 */

// CLIENT ////////////////////////////////////////
#if EV3_BRICK == 0

%rename( brick_addr ) ev3_brick_addr;
extern char *ev3_brick_addr;
%rename( brick_port ) ev3_brick_port;
extern uint16_t ev3_brick_port;

//////////////////////////////////////////////////
#endif

extern int ev3_init( void );
extern void ev3_uninit( void );

extern size_t ev3_write_binary( const char *fn, char *STRING, size_t LENGTH );
extern size_t ev3_write( const char *fn, char *value );
extern size_t ev3_write_bool( const char *fn, bool value );
extern size_t ev3_write_int( const char *fn, int value );
extern size_t ev3_write_dword( const char *fn, uint32_t value );
extern size_t ev3_write_byte( const char *fn, uint8_t value );
extern size_t ev3_write_float( const char *fn, float value );

extern size_t ev3_multi_write_binary( uint8_t *sn, uint16_t pos, const char *fn, char *STRING, size_t LENGTH );
extern size_t ev3_multi_write( uint8_t *sn, uint16_t pos, const char *fn, char *value );
extern size_t ev3_multi_write_bool( uint8_t *sn, uint16_t pos, const char *fn, bool value );
extern size_t ev3_multi_write_int( uint8_t *sn, uint16_t pos, const char *fn, int value );
extern size_t ev3_multi_write_dword( uint8_t *sn, uint16_t pos, const char *fn, uint32_t value );
extern size_t ev3_multi_write_byte( uint8_t *sn, uint16_t pos, const char *fn, uint8_t value );
extern size_t ev3_multi_write_float( uint8_t *sn, uint16_t pos, const char *fn, float value );

extern size_t ev3_read_binary( const char *fn, char *buf, size_t sz );
extern size_t ev3_read( const char *fn, char *buf, size_t sz );

#ifndef SWIGRUBY
extern size_t ev3_read_bool( const char *fn, bool *buf );

#endif
extern size_t ev3_read_int( const char *fn, int *buf );
extern size_t ev3_read_dword( const char *fn, uint32_t *buf );
extern size_t ev3_read_byte( const char *fn, uint8_t *buf );
extern size_t ev3_read_float( const char *fn, float *buf );

extern size_t ev3_listdir( const char *fn, char *buf, size_t sz );
extern size_t ev3_read_keys( uint8_t *buf );
extern bool ev3_poweroff( void );

enum {
	EV3_KEY__NONE_ = 0,

	EV3_KEY_UP     = 0x01L,
	EV3_KEY_DOWN   = 0x02L,
	EV3_KEY_LEFT   = 0x04L,
	EV3_KEY_RIGHT  = 0x08L,
	EV3_KEY_CENTER = 0x10L,
	EV3_KEY_BACK   = 0x20L,
};

#define DESC_LIMIT    64
#define DESC_VEC_LEN  4

/**
 *  \brief Identifiers of LEDs.
 */
enum {
	EV3_LEFT_GREEN,
	EV3_RIGHT_GREEN,
	EV3_LEFT_RED,
	EV3_RIGHT_RED,
	LED_OUTA,
	LED_OUTB,
	LED_OUTC,
	LED_OUTD,

	LED__COUNT_  /**< Count of EV3 LEDs. */
};

/**
 *  \brief Triggers identifiers of LEDs.
 */
enum {
	TRIGGER_NONE,
	TRIGGER_MMC0,
	TRIGGER_TIMER,
	TRIGGER_HEARTBEAT,
	TRIGGER_DEFAULT_ON,
	TRIGGER_TRANSIENT,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING,
	TRIGGER_LEGOEV3_BATTERY_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID,
	TRIGGER_RFKILL0,
	TRIGGER_PHY0RX,
	TRIGGER_PHY0TX,
	TRIGGER_PHY0ASSOC,
	TRIGGER_PHY0RADIO,
	TRIGGER_RFKILL1,

	TRIGGER__COUNT_  /**< Count of EV3 triggers. */
};

#define LED_ATTR__COUNT_ 5

/**
 *  \brief Read "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Write "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_brightness( uint8_t inx, byte value );

/**
 *  \brief Read "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_off( uint8_t inx, int *buf );

/**
 *  \brief Write "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_off( uint8_t inx, int value );

/**
 *  \brief Read "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_on( uint8_t inx, int *buf );

/**
 *  \brief Write "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_on( uint8_t inx, int value );

/**
 *  \brief Read "max_brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_max_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Read "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_led_trigger( uint8_t inx, char *buf, size_t sz );

/**
 *  \brief Write "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger( uint8_t inx, char *value );

/**
 *  \brief Read "trigger" attribute of the LED and get the index.
 *  \param inx Index of the LED.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern INX_T get_led_trigger_inx( uint8_t inx );

/**
 *  \brief Write "trigger" attribute of the LED by the index.
 *  \param inx Index of the LED.
 *  \param trigger_inx Index of the trigger.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger_inx( uint8_t inx, INX_T trigger_inx );

/**
 *  \brief Get name of the specified LED trigger.
 *  \param trigger_inx Index of the trigger.
 *  \return Requested value.
 */
extern const char *ev3_led_trigger( INX_T trigger_inx );

/**
 *  \brief Identifiers of light locations.
 */
enum {
	LIT_LEFT,
	LIT_RIGHT,

	LIT__LOC__
};

/**
 *  \brief Identifiers of light colors.
 */
enum {
	LIT_OFF,
	LIT_GREEN,
	LIT_RED,
	LIT_AMBER,

	LIT__COL__
};

/**
 *  \brief Light colors.
 */
extern const char *const LIT_COLOR[];

/**
 *  \brief Get the light color name.
 *  \param col Color.
 *  \return Color name.
 */
extern const char *light_color( uint8_t col );

/**
 *  \brief Set the light color.
 *  \param loc Location.
 *  \param col Color.
 */
extern void set_light( uint8_t loc, uint8_t col );

/**
 *  \brief Get the light color.
 *  \param loc Location.
 *  \return Color.
 */
extern uint8_t get_light( uint8_t loc );

/**
 *  \brief Set the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \param trigger Index of trigger.
 */
extern void set_light_trigger( uint8_t loc, uint8_t col, uint8_t trigger );

/**
 *  \brief Get the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_light_trigger( uint8_t loc, uint8_t col );

/**
 *  \brief Set the light blink.
 *  \param loc Location.
 *  \param col Color.
 *  \param delay_on Time of "on" state in ms.
 *  \param delay_off Time of "off" state in ms.
 */
extern void set_light_blink( uint8_t loc, uint8_t col, int delay_on, int delay_off );

/**
 *  \brief Check the light is blinking.
 *  \param loc Location.
 *  \param col Color.
 *  \return Flag - the light is blinking.
 */
extern bool get_light_blink( uint8_t loc, uint8_t col );

#define PORT_DIR  "/sys/class/lego-port"  /**< Directory of EV3 ports. */

/**
 *  \brief Structure of a EV3 port descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< EV3 port type. */
	uint8_t port;  /**< EV3 port EV3 port. */
	uint8_t extport;  /**< EV3 port extended port. */
	uint8_t addr;  /**< EV3 port I2C address. */

} EV3_PORT;

#define PORT_DESC__LIMIT_  DESC_LIMIT  /**< Limit of EV3 port descriptors. */

#define PORT__NONE_  PORT_DESC__LIMIT_  /**< EV3 port is not found. */

/**
 *  \brief Vector of EV3 port descriptors (filled by \ref ev3_port_init).
 */
extern EV3_PORT ev3_port[ PORT_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of EV3 port types.
 */
enum {
	PORT_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	HT_NXT_SMUX_PORT,
	LEGOEV3_INPUT_PORT,
	LEGOEV3_OUTPUT_PORT,
	MS_EV3_SMUX_PORT,
	MS_NXTMMX_OUT_PORT,
	WEDO_PORT,

	PORT_TYPE__COUNT_,  /**< Count of EV3 port types. */
	PORT_TYPE__UNKNOWN_ = PORT_TYPE__COUNT_
};

/**
 *  \brief Identifiers of EV3 port "mode" attribute.
 */
enum {
	PORT_MODE__NONE_ = 0,

	HT_NXT_SMUX_PORT_ANALOG, HT_NXT_SMUX_ANALOG = HT_NXT_SMUX_PORT_ANALOG,
	HT_NXT_SMUX_PORT_I2C, HT_NXT_SMUX_I2C = HT_NXT_SMUX_PORT_I2C,			
	LEGOEV3_INPUT_PORT_AUTO, INPUT_AUTO = LEGOEV3_INPUT_PORT_AUTO,
	LEGOEV3_INPUT_PORT_NXT_ANALOG, INPUT_NXT_ANALOG = LEGOEV3_INPUT_PORT_NXT_ANALOG,
	LEGOEV3_INPUT_PORT_NXT_COLOR, INPUT_NXT_COLOR = LEGOEV3_INPUT_PORT_NXT_COLOR,
	LEGOEV3_INPUT_PORT_NXT_I2C, INPUT_NXT_I2C = LEGOEV3_INPUT_PORT_NXT_I2C,
	LEGOEV3_INPUT_PORT_OTHER_I2C, INPUT_OTHER_I2C = LEGOEV3_INPUT_PORT_OTHER_I2C,
	LEGOEV3_INPUT_PORT_EV3_ANALOG, INPUT_EV3_ANALOG = LEGOEV3_INPUT_PORT_EV3_ANALOG,
	LEGOEV3_INPUT_PORT_EV3_UART, INPUT_EV3_UART = LEGOEV3_INPUT_PORT_EV3_UART,
	LEGOEV3_INPUT_PORT_OTHER_UART, INPUT_OTHER_UART = LEGOEV3_INPUT_PORT_OTHER_UART,
	LEGOEV3_INPUT_PORT_RAW, INPUT_RAW = LEGOEV3_INPUT_PORT_RAW,			
	LEGOEV3_OUTPUT_PORT_AUTO, OUTPUT_AUTO = LEGOEV3_OUTPUT_PORT_AUTO,
	LEGOEV3_OUTPUT_PORT_TACHO_MOTOR, OUTPUT_TACHO_MOTOR = LEGOEV3_OUTPUT_PORT_TACHO_MOTOR,
	LEGOEV3_OUTPUT_PORT_DC_MOTOR, OUTPUT_DC_MOTOR = LEGOEV3_OUTPUT_PORT_DC_MOTOR,
	LEGOEV3_OUTPUT_PORT_LED, OUTPUT_LED = LEGOEV3_OUTPUT_PORT_LED,
	LEGOEV3_OUTPUT_PORT_RAW, OUTPUT_RAW = LEGOEV3_OUTPUT_PORT_RAW,			
	MS_EV3_SMUX_PORT_UART, MS_EV3_SMUX_UART = MS_EV3_SMUX_PORT_UART,
	MS_EV3_SMUX_PORT_ANALOG, MS_EV3_SMUX_ANALOG = MS_EV3_SMUX_PORT_ANALOG,			
	MS_NXTMMX_OUT_PORT_TACHO_MOTOR, MS_NXTMMX_TACHO_MOTOR = MS_NXTMMX_OUT_PORT_TACHO_MOTOR,			
	WEDO_PORT_AUTO, WEDO_AUTO = WEDO_PORT_AUTO,
	PORT_MODE__COUNT_,  /**< Count of EV3 port "mode" attribute. */
	PORT_MODE__UNKNOWN_ = PORT_MODE__COUNT_
};

/**
 *  \brief Read "address" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_address( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "driver_name" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_mode( uint8_t sn, char *value );

/**
 *  \brief Write "mode" attribute of several EV3 ports.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_port_mode( uint8_t *sn, char *value );

/**
 *  \brief Read "modes" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "set_device" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_set_device( uint8_t sn, char *value );

/**
 *  \brief Write "set_device" attribute of several EV3 ports.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_port_set_device( uint8_t *sn, char *value );

/**
 *  \brief Read "status" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_status( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified EV3 port type.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern const char *ev3_port_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the EV3 port type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_port_type_inx( uint8_t sn );

/**
 *  \brief Read EV3 port attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_port_desc( uint8_t sn, EV3_PORT *desc );

/**
 *  \brief Get descriptor of the EV3 port.
 *  \param sn Sequence number.
 *  \return Pointer to the EV3 port descriptor.
 */
extern EV3_PORT *ev3_port_desc( uint8_t sn );

/**
 *  \brief Get type from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_port_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_extport( uint8_t sn );

/**
 *  \brief Get I2C address from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_port_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified EV3 port type.
 *  \param type_inx EV3 port type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_type( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the EV3 port by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified EV3 port mode.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Requested value.
 */
extern const char *ev3_port_mode( INX_T mode_inx );

/**
 *  \brief Read "mode" attribute of the specified EV3 port type and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern INX_T get_port_mode_inx_of_type( uint8_t sn, INX_T type_inx );

/**
 *  \brief Read "mode" attribute of the EV3 port and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 *
 *  This function gets type of the EV3 port from the descriptor.
 */
extern INX_T get_port_mode_inx( uint8_t sn );

/**
 *  \brief Write "mode" attribute of the EV3 port by the index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Count of written bytes.
 */
extern size_t set_port_mode_inx( uint8_t sn, INX_T mode_inx );

/**
 *  \brief Write "mode" attribute of several EV3 ports by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Count of written bytes.
 */
extern size_t multi_set_port_mode_inx( uint8_t *sn, INX_T mode_inx );

/**
 *  \brief Detect connected EV3 ports.
 *  \return Number of found EV3 ports or -1 in case of an error.
 */
extern int ev3_port_init( void );

/**
 *  \brief Identifiers of EV3 ports and extended ports.
 */
#define EV3_PORT__NONE_  0  /* XXX: 0 is used */
#define EXT_PORT__NONE_  EV3_PORT__NONE_

#define INPUT_1  49  // '1'
#define INPUT_2  50  // '2'
#define INPUT_3  51  // '3'
#define INPUT_4  52  // '4'
			
#define OUTPUT_A  65  // 'A'
#define OUTPUT_B  66  // 'B'
#define OUTPUT_C  67  // 'C'
#define OUTPUT_D  68  // 'D'
				
#define MUX_1  49  // '1'
#define MUX_2  50  // '2'
#define MUX_3  51  // '3'
#define MUX_4  52  // '4'
#define SERVO__OFFSET_  16
#define SERVO_1  65  // 'A'
#define SERVO_2  66  // 'B'
#define SERVO_3  67  // 'C'
#define SERVO_4  68  // 'D'
#define SERVO_5  69  // 'E'
#define SERVO_6  70  // 'F'
#define SERVO_7  71  // 'G'
#define SERVO_8  72  // 'H'
#define NXTMMX__OFFSET_  28
#define NXTMMX_1  77  // 'M'
#define NXTMMX_2  78  // 'N'
#define WEDO__OFFSET_  48
#define WEDO_1  97  // 'a'
#define WEDO_2  98  // 'b'
#define WEDO_3  99  // 'c'
#define WEDO_4  100  // 'd'

/**
 *  \brief Search of a port sequence number by the EV3 port and the extended port.
 *  \param port EV3 port index.
 *  \param extport Extended port index.
 *  \return Port sequence number.
 */
extern uint8_t ev3_search_port( uint8_t port, uint8_t extport );

/**
 *  \brief Parse name of the EV3 port.
 *  \param name Port name.
 *  \param port Buffer for the EV3 port index.
 *  \param extport Buffer for the extended port index.
 *  \param addr Buffer for the address.
 */
extern void ev3_parse_port_name( char *name, uint8_t *port, uint8_t *extport, uint8_t *addr );

/**
 *  \brief Assemble name of the EV3 port.
 *  \param port EV3 port index.
 *  \param extport Extended port index.
 *  \param addr Address.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_port_name( uint8_t port, uint8_t extport, uint8_t addr, char *buf );

#define SENSOR_DIR  "/sys/class/lego-sensor"  /**< Directory of sensors. */

/**
 *  \brief Structure of a sensor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Sensor type. */
	uint8_t port;  /**< Sensor EV3 port. */
	uint8_t extport;  /**< Sensor extended port. */
	uint8_t addr;  /**< Sensor I2C address. */

} EV3_SENSOR;

#define SENSOR_DESC__LIMIT_  DESC_LIMIT  /**< Limit of sensor descriptors. */

#define SENSOR__NONE_  SENSOR_DESC__LIMIT_  /**< Sensor is not found. */

/**
 *  \brief Vector of sensor descriptors (filled by \ref ev3_sensor_init).
 */
extern EV3_SENSOR ev3_sensor[ SENSOR_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of sensor types.
 */
enum {
	SENSOR_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	EV3_ANALOG_XX,
	NXT_ANALOG,
	PIXY_LEGO,
	DI_DFLEX,
	FCL_9DOF,
	FCL_ADC,
	FCL_ALTITUDE,
	FCL_GESTURE,
	FCL_HUMIDITY,
	FCL_IR,
	FCL_LIGHT,
	HT_NXT_COLOR,
	HT_NXT_ANGLE,
	HT_NXT_ACCEL,
	HT_NXT_BAROMETRIC,
	HT_NXT_COLOR_V2,
	HT_NXT_EOPD,
	HT_NXT_FORCE,
	HT_NXT_GYRO,
	HT_NXT_IR_LINK,
	HT_NXT_IR_RECEIVER,
	HT_NXT_PIR,
	HT_NXT_COMPASS,
	HT_NXT_MAG,
	HT_NXT_IR_SEEK_V2,
	HT_NXT_SMUX,
	HT_SUPER_PRO,
	LEGO_EV3_US,
	LEGO_EV3_GYRO,
	LEGO_EV3_COLOR,
	LEGO_EV3_TOUCH,
	LEGO_EV3_IR,
	WEDO_HUB,
	WEDO_MOTION,
	WEDO_TILT,
	LEGO_POWER_STORAGE,
	LEGO_NXT_TEMP,
	LEGO_NXT_TOUCH,
	LEGO_NXT_LIGHT,
	LEGO_NXT_SOUND,
	LEGO_NXT_US,
	MI_XG1300L,
	MS_ABSOLUTE_IMU,
	MS_ANGLE,
	MS_EV3_SMUX,
	MS_LIGHT_ARRAY,
	MS_LINE_LEADER,
	MS_NXTCAM,
	MS_NXTMMX,
	MS_8CH_SERVO,
	MS_PPS58_NX,
	MS_PIXY_ADAPTER,
	MS_NXT_TOUCH_MUX,

	SENSOR_TYPE__COUNT_,  /**< Count of sensor types. */
	SENSOR_TYPE__UNKNOWN_ = SENSOR_TYPE__COUNT_
};

/**
 *  \brief Identifiers of sensor "mode" attribute.
 */
enum {
	SENSOR_MODE__NONE_ = 0,

	EV3_ANALOG_XX_ANALOG, 			
	NXT_ANALOG_ANALOG_0, 
	NXT_ANALOG_ANALOG_1, 			
	PIXY_LEGO_ALL, 
	PIXY_LEGO_SIG1, 
	PIXY_LEGO_SIG2, 
	PIXY_LEGO_SIG3, 
	PIXY_LEGO_SIG4, 
	PIXY_LEGO_SIG5, 
	PIXY_LEGO_SIG6, 
	PIXY_LEGO_SIG7, 			
	DI_DFLEX_FLEX, 			
	FCL_9DOF_GYRO, 
	FCL_9DOF_ACC, 
	FCL_9DOF_MAGNET, 			
	FCL_ADC_CH1_VOLTAGE, 
	FCL_ADC_CH2_VOLTAGE, 
	FCL_ADC_VOLTAGE, 			
	FCL_ALTITUDE_PRESSURE, 
	FCL_ALTITUDE_ALTITUDE, 			
	FCL_GESTURE_GESTURE, 
	FCL_GESTURE_PROXIMITY, 
	FCL_GESTURE_RGB_RAW, 
	FCL_GESTURE_CLEAR, 			
	FCL_HUMIDITY_CENTIGRADE, 
	FCL_HUMIDITY_FAHRENHEIT, 
	FCL_HUMIDITY_HUMIDITY, 			
	FCL_IR_IR_DATA, 			
	FCL_LIGHT_ILLUMINANCE, 			
	HT_NXT_COLOR_COLOR, 
	HT_NXT_COLOR_RED, 
	HT_NXT_COLOR_GREEN, 
	HT_NXT_COLOR_BLUE, 
	HT_NXT_COLOR_RAW, 
	HT_NXT_COLOR_NORM, 
	HT_NXT_COLOR_ALL, 			
	HT_NXT_ANGLE_ANGLE, 
	HT_NXT_ANGLE_ANGLE_ACC, 
	HT_NXT_ANGLE_SPEED, 			
	HT_NXT_ACCEL_ACCEL, 
	HT_NXT_ACCEL_ALL, 			
	HT_NXT_BAROMETRIC_PRESS, 
	HT_NXT_BAROMETRIC_TEMP, 			
	HT_NXT_COLOR_V2_COLOR, 
	HT_NXT_COLOR_V2_RED, 
	HT_NXT_COLOR_V2_GREEN, 
	HT_NXT_COLOR_V2_BLUE, 
	HT_NXT_COLOR_V2_WHITE, 
	HT_NXT_COLOR_V2_NORM, 
	HT_NXT_COLOR_V2_ALL, 
	HT_NXT_COLOR_V2_RAW, 			
	HT_NXT_EOPD_LONG, 
	HT_NXT_EOPD_SHORT, 			
	HT_NXT_FORCE_FORCE, 			
	HT_NXT_GYRO_GYRO, 			
	HT_NXT_IR_LINK_IRLINK, 			
	HT_NXT_IR_RECEIVER_1_MOTOR, 
	HT_NXT_IR_RECEIVER_8_MOTOR, 			
	HT_NXT_PIR_PROX, 			
	HT_NXT_COMPASS_COMPASS, 			
	HT_NXT_MAG_MAG, 			
	HT_NXT_IR_SEEK_V2_DC, 
	HT_NXT_IR_SEEK_V2_AC, 
	HT_NXT_IR_SEEK_V2_DC_ALL, 
	HT_NXT_IR_SEEK_V2_AC_ALL, 			
	HT_NXT_SMUX_MUX, 			
	HT_SUPER_PRO_AIN, 
	HT_SUPER_PRO_DIN, 
	HT_SUPER_PRO_DOUT, 
	HT_SUPER_PRO_DCTRL, 
	HT_SUPER_PRO_STROBE, 
	HT_SUPER_PRO_LED, 
	HT_SUPER_PRO_AOUT_0, 
	HT_SUPER_PRO_AOUT_1, 			
	LEGO_EV3_US_US_DIST_CM, US_US_DIST_CM = LEGO_EV3_US_US_DIST_CM,
	LEGO_EV3_US_US_DIST_IN, US_US_DIST_IN = LEGO_EV3_US_US_DIST_IN,
	LEGO_EV3_US_US_LISTEN, US_US_LISTEN = LEGO_EV3_US_US_LISTEN,
	LEGO_EV3_US_US_SI_CM, US_US_SI_CM = LEGO_EV3_US_US_SI_CM,
	LEGO_EV3_US_US_SI_IN, US_US_SI_IN = LEGO_EV3_US_US_SI_IN,
	LEGO_EV3_US_US_DC_CM, US_US_DC_CM = LEGO_EV3_US_US_DC_CM,
	LEGO_EV3_US_US_DC_IN, US_US_DC_IN = LEGO_EV3_US_US_DC_IN,			
	LEGO_EV3_GYRO_GYRO_ANG, GYRO_GYRO_ANG = LEGO_EV3_GYRO_GYRO_ANG,
	LEGO_EV3_GYRO_GYRO_RATE, GYRO_GYRO_RATE = LEGO_EV3_GYRO_GYRO_RATE,
	LEGO_EV3_GYRO_GYRO_FAS, GYRO_GYRO_FAS = LEGO_EV3_GYRO_GYRO_FAS,
	LEGO_EV3_GYRO_GYRO_G_AND_A, GYRO_GYRO_G_AND_A = LEGO_EV3_GYRO_GYRO_G_AND_A,
	LEGO_EV3_GYRO_GYRO_CAL, GYRO_GYRO_CAL = LEGO_EV3_GYRO_GYRO_CAL,			
	LEGO_EV3_COLOR_COL_REFLECT, COLOR_COL_REFLECT = LEGO_EV3_COLOR_COL_REFLECT,
	LEGO_EV3_COLOR_COL_AMBIENT, COLOR_COL_AMBIENT = LEGO_EV3_COLOR_COL_AMBIENT,
	LEGO_EV3_COLOR_COL_COLOR, COLOR_COL_COLOR = LEGO_EV3_COLOR_COL_COLOR,
	LEGO_EV3_COLOR_REF_RAW, COLOR_REF_RAW = LEGO_EV3_COLOR_REF_RAW,
	LEGO_EV3_COLOR_RGB_RAW, COLOR_RGB_RAW = LEGO_EV3_COLOR_RGB_RAW,
	LEGO_EV3_COLOR_COL_CAL, COLOR_COL_CAL = LEGO_EV3_COLOR_COL_CAL,			
	LEGO_EV3_TOUCH_TOUCH, TOUCH_TOUCH = LEGO_EV3_TOUCH_TOUCH,			
	LEGO_EV3_IR_IR_PROX, IR_IR_PROX = LEGO_EV3_IR_IR_PROX,
	LEGO_EV3_IR_IR_SEEK, IR_IR_SEEK = LEGO_EV3_IR_IR_SEEK,
	LEGO_EV3_IR_IR_REMOTE, IR_IR_REMOTE = LEGO_EV3_IR_IR_REMOTE,
	LEGO_EV3_IR_IR_REM_A, IR_IR_REM_A = LEGO_EV3_IR_IR_REM_A,
	LEGO_EV3_IR_IR_S_ALT, IR_IR_S_ALT = LEGO_EV3_IR_IR_S_ALT,
	LEGO_EV3_IR_IR_CAL, IR_IR_CAL = LEGO_EV3_IR_IR_CAL,			
	WEDO_HUB_HUB, 			
	WEDO_MOTION_PROX, 
	WEDO_MOTION_RAW, 			
	WEDO_TILT_TILT, 
	WEDO_TILT_TILT_AXIS, 
	WEDO_TILT_RAW, 			
	LEGO_POWER_STORAGE_IN_VOLT, 
	LEGO_POWER_STORAGE_IN_AMP, 
	LEGO_POWER_STORAGE_OUT_VOLT, 
	LEGO_POWER_STORAGE_OUT_AMP, 
	LEGO_POWER_STORAGE_JOULE, 
	LEGO_POWER_STORAGE_IN_WATT, 
	LEGO_POWER_STORAGE_OUT_WATT, 
	LEGO_POWER_STORAGE_ALL, 			
	LEGO_NXT_TEMP_NXT_TEMP_C, 
	LEGO_NXT_TEMP_NXT_TEMP_F, 			
	LEGO_NXT_TOUCH_TOUCH, 			
	LEGO_NXT_LIGHT_REFLECT, 
	LEGO_NXT_LIGHT_AMBIENT, 			
	LEGO_NXT_SOUND_DB, 
	LEGO_NXT_SOUND_DBA, 			
	LEGO_NXT_US_US_DIST_CM, 
	LEGO_NXT_US_US_DIST_IN, 
	LEGO_NXT_US_US_SI_CM, 
	LEGO_NXT_US_US_SI_IN, 
	LEGO_NXT_US_US_LISTEN, 			
	MI_XG1300L_ANGLE, 
	MI_XG1300L_SPEED, 
	MI_XG1300L_ACCEL, 
	MI_XG1300L_ALL, 			
	MS_ABSOLUTE_IMU_TILT, 
	MS_ABSOLUTE_IMU_ACCEL, 
	MS_ABSOLUTE_IMU_COMPASS, 
	MS_ABSOLUTE_IMU_MAG, 
	MS_ABSOLUTE_IMU_GYRO, 
	MS_ABSOLUTE_IMU_ALL, 			
	MS_ANGLE_ANGLE, 
	MS_ANGLE_ANGLE2, 
	MS_ANGLE_SPEED, 
	MS_ANGLE_ALL, 			
	MS_EV3_SMUX_MUX, 			
	MS_LIGHT_ARRAY_CAL, 
	MS_LIGHT_ARRAY_RAW, 			
	MS_LINE_LEADER_PID, 
	MS_LINE_LEADER_PID_ALL, 
	MS_LINE_LEADER_CAL, 
	MS_LINE_LEADER_RAW, 			
	MS_NXTCAM_TRACK, 			
	MS_NXTMMX_STATUS, 
	MS_NXTMMX_STATUS_OLD, 			
	MS_8CH_SERVO_V3, 
	MS_8CH_SERVO_OLD, 			
	MS_PPS58_NX_RAW, 
	MS_PPS58_NX_ABS_PSI, 
	MS_PPS58_NX_ABS_MBAR, 
	MS_PPS58_NX_ABS_KPA, 
	MS_PPS58_NX_REL_PSI, 
	MS_PPS58_NX_REL_MBAR, 
	MS_PPS58_NX_REL_KPA, 			
	MS_PIXY_ADAPTER_TRACK, 			
	MS_NXT_TOUCH_MUX_TOUCH_MUX, 
	SENSOR_MODE__COUNT_,  /**< Count of sensor "mode" attribute. */
	SENSOR_MODE__UNKNOWN_ = SENSOR_MODE__COUNT_
};

/**
 *  \brief Identifiers of sensor "command" attribute.
 */
enum {
	SENSOR_COMMAND__NONE_ = 0,

	HT_NXT_ANGLE_RESET, 
	HT_NXT_ANGLE_CAL, 																																							
	HT_NXT_SMUX_HALT, 
	HT_NXT_SMUX_DETECT, 
	HT_NXT_SMUX_RUN, 																					
	WEDO_HUB_OUT_OFF, 
	WEDO_HUB_OUT_ON, 
	WEDO_HUB_CLEAR_ERR, 																											
	MI_XG1300L_RESET, 
	MI_XG1300L_ACCEL_2G, 
	MI_XG1300L_ACCEL_4G, 
	MI_XG1300L_ACCEL_8G, 			
	MS_ABSOLUTE_IMU_BEGIN_COMP_CAL, 
	MS_ABSOLUTE_IMU_END_COMP_CAL, 
	MS_ABSOLUTE_IMU_ACCEL_2G, 
	MS_ABSOLUTE_IMU_ACCEL_4G, 
	MS_ABSOLUTE_IMU_ACCEL_8G, 
	MS_ABSOLUTE_IMU_ACCEL_16G, 			
	MS_ANGLE_RESET, 						
	MS_LIGHT_ARRAY_CAL_WHITE, 
	MS_LIGHT_ARRAY_CAL_BLACK, 
	MS_LIGHT_ARRAY_SLEEP, 
	MS_LIGHT_ARRAY_WAKE, 
	MS_LIGHT_ARRAY_60HZ, 
	MS_LIGHT_ARRAY_50HZ, 
	MS_LIGHT_ARRAY_UNIVERSAL, 			
	MS_LINE_LEADER_CAL_WHITE, 
	MS_LINE_LEADER_CAL_BLACK, 
	MS_LINE_LEADER_SLEEP, 
	MS_LINE_LEADER_WAKE, 
	MS_LINE_LEADER_INV_COL, 
	MS_LINE_LEADER_RST_COL, 
	MS_LINE_LEADER_SNAP, 
	MS_LINE_LEADER_60HZ, 
	MS_LINE_LEADER_50HZ, 
	MS_LINE_LEADER_UNIVERSAL, 			
	MS_NXTCAM_TRACK_ON, 
	MS_NXTCAM_TRACK_OFF, 
	MS_NXTCAM_TRACK_OBJ, 
	MS_NXTCAM_TRACK_LINE, 
	MS_NXTCAM_SORT_SIZE, 
	MS_NXTCAM_SORT_COL, 									
	MS_PPS58_NX_ZERO, 			
	MS_PIXY_ADAPTER_SORT_SIZE, 
	MS_PIXY_ADAPTER_SORT_COL, 			
	SENSOR_COMMAND__COUNT_,  /**< Count of sensor "command" attribute. */
	SENSOR_COMMAND__UNKNOWN_ = SENSOR_COMMAND__COUNT_
};

/**
 *  \brief Read "address" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_address( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz );

/**
 *  \brief Write "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz );

/**
 *  \brief Write "bin_data" attribute of several sensors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_bin_data( uint8_t *sn, byte *value, size_t sz );

/**
 *  \brief Read "bin_data_format" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command( uint8_t sn, char *value );

/**
 *  \brief Write "command" attribute of several sensors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_command( uint8_t *sn, char *value );

/**
 *  \brief Read "commands" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "direct" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_direct( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "direct" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_direct( uint8_t sn, char *value );

/**
 *  \brief Write "direct" attribute of several sensors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_direct( uint8_t *sn, char *value );

/**
 *  \brief Read "decimals" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_decimals( uint8_t sn, dword *buf );

/**
 *  \brief Read "driver_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "fw_version" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode( uint8_t sn, char *value );

/**
 *  \brief Write "mode" attribute of several sensors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_mode( uint8_t *sn, char *value );

/**
 *  \brief Read "modes" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "num_values" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_num_values( uint8_t sn, dword *buf );

/**
 *  \brief Read "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_poll_ms( uint8_t sn, dword *buf );

/**
 *  \brief Write "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_poll_ms( uint8_t sn, dword value );

/**
 *  \brief Write "poll_ms" attribute of several sensors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_poll_ms( uint8_t *sn, dword value );

/**
 *  \brief Read "units" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_units( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "value0" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value0( uint8_t sn, float *buf );

/**
 *  \brief Read "value1" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value1( uint8_t sn, float *buf );

/**
 *  \brief Read "value2" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value2( uint8_t sn, float *buf );

/**
 *  \brief Read "value3" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value3( uint8_t sn, float *buf );

/**
 *  \brief Read "value4" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value4( uint8_t sn, float *buf );

/**
 *  \brief Read "value5" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value5( uint8_t sn, float *buf );

/**
 *  \brief Read "value6" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value6( uint8_t sn, float *buf );

/**
 *  \brief Read "value7" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value7( uint8_t sn, float *buf );

/**
 *  \brief Read "text_value" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_text_value( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "value" attribute of the sensor.
 *  \param inx Attribute index.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
	 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf );

/**
 *  \brief Get name of the specified sensor type.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern const char *ev3_sensor_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the sensor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_sensor_type_inx( uint8_t sn );

/**
 *  \brief Read sensor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_desc( uint8_t sn, EV3_SENSOR *desc );

/**
 *  \brief Get descriptor of the sensor.
 *  \param sn Sequence number.
 *  \return Pointer to the sensor descriptor.
 */
extern EV3_SENSOR *ev3_sensor_desc( uint8_t sn );

/**
 *  \brief Get type from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_sensor_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_extport( uint8_t sn );

/**
 *  \brief Get I2C address from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the sensor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_sensor_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified sensor type.
 *  \param type_inx Sensor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the sensor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified sensor mode.
 *  \param mode_inx Index of the sensor mode.
 *  \return Requested value.
 */
extern const char *ev3_sensor_mode( INX_T mode_inx );

/**
 *  \brief Read "mode" attribute of the specified sensor type and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern INX_T get_sensor_mode_inx_of_type( uint8_t sn, INX_T type_inx );

/**
 *  \brief Read "mode" attribute of the sensor and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 *
 *  This function gets type of the sensor from the descriptor.
 */
extern INX_T get_sensor_mode_inx( uint8_t sn );

/**
 *  \brief Write "mode" attribute of the sensor by the index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the sensor mode.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode_inx( uint8_t sn, INX_T mode_inx );

/**
 *  \brief Write "mode" attribute of several sensors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param mode_inx Index of the sensor mode.
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_mode_inx( uint8_t *sn, INX_T mode_inx );

/**
 *  \brief Get name of the specified sensor command.
 *  \param command_inx Index of the sensor command.
 *  \return Requested value.
 */
extern const char *ev3_sensor_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the sensor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the sensor command.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Write "command" attribute of several sensors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param command_inx Index of the sensor command.
 *  \return Count of written bytes.
 */
extern size_t multi_set_sensor_command_inx( uint8_t *sn, INX_T command_inx );

/**
 *  \brief Detect connected sensors.
 *  \return Number of found sensors or -1 in case of an error.
 */
extern int ev3_sensor_init( void );

/**
 *  \brief Identifiers of LEGO_EV3_IR sensor values for IR_REMOTE mode.
 */
enum {
	IR_REMOTE__NONE_   = 0,

	RED_UP             = 1,
	RED_DOWN           = 2,
	BLUE_UP            = 3,
	BLUE_DOWN          = 4,
	RED_UP_BLUE_UP     = 5,
	RED_UP_BLUE_DOWN   = 6,
	RED_DOWN_BLUE_UP   = 7,
	RED_DOWN_BLUE_DOWN = 8,
	BEACON_MODE_ON     = 9,
	RED_UP_RED_DOWN    = 10,
	BLUE_UP_BLUE_DOWN  = 11,
};

#define TACHO_DIR  "/sys/class/tacho-motor"  /**< Directory of tachos. */

/**
 *  \brief Structure of a tacho descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Tacho type. */
	uint8_t port;  /**< Tacho EV3 port. */
	uint8_t extport;  /**< Tacho extended port. */

} EV3_TACHO;

#define TACHO_DESC__LIMIT_  DESC_LIMIT  /**< Limit of tacho descriptors. */

#define TACHO__NONE_  TACHO_DESC__LIMIT_  /**< Tacho is not found. */

/**
 *  \brief Vector of tacho descriptors (filled by \ref ev3_tacho_init).
 */
extern EV3_TACHO ev3_tacho[ TACHO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of tacho types.
 */
enum {
	TACHO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	LEGO_EV3_L_MOTOR,
	LEGO_EV3_M_MOTOR,
	FI_L12_EV3,

	TACHO_TYPE__COUNT_,  /**< Count of tacho types. */
	TACHO_TYPE__UNKNOWN_ = TACHO_TYPE__COUNT_
};

/**
 *  \brief Common identifiers of tacho "command" attribute.
 */
enum {
	TACHO_COMMAND__NONE_ = 0,

	TACHO_RUN_FOREVER,
	TACHO_RUN_TO_ABS_POS,
	TACHO_RUN_TO_REL_POS,
	TACHO_RUN_TIMED,
	TACHO_RUN_DIRECT,
	TACHO_STOP,
	TACHO_RESET,

	TACHO_COMMAND__COUNT_,  /**< Count of tacho "command" attribute. */
	TACHO_COMMAND__UNKNOWN_ = TACHO_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of tacho "polarity" attribute.
 */
enum {
	TACHO_POLARITY__NONE_ = 0,

	TACHO_NORMAL,
	TACHO_INVERSED,

	TACHO_POLARITY__COUNT_,  /**< Count of tacho "polarity" attribute. */
	TACHO_POLARITY__UNKNOWN_ = TACHO_POLARITY__COUNT_
};

/**
 *  \brief Common identifiers of tacho "stop_action" attribute.
 */
enum {
	TACHO_STOP_ACTION__NONE_ = 0,

	TACHO_COAST,
	TACHO_BRAKE,
	TACHO_HOLD,

	TACHO_STOP_ACTION__COUNT_,  /**< Count of tacho "stop_action" attribute. */
	TACHO_STOP_ACTION__UNKNOWN_ = TACHO_STOP_ACTION__COUNT_
};

/**
 *  \brief Common identifiers of tacho "state" attribute.
 */
enum {
	TACHO_STATE__NONE_ = 0,

	TACHO_RUNNING = 0x1L,
	TACHO_RAMPING = 0x2L,
	TACHO_HOLDING = 0x4L,
	TACHO_OVERLOADED = 0x8L,
	TACHO_STALLED = 0x10L,

};

/**
 *  \brief Read "address" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_address( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_command( uint8_t sn, char *value );

/**
 *  \brief Write "command" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_command( uint8_t *sn, char *value );

/**
 *  \brief Read "commands" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "count_per_rot" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_count_per_rot( uint8_t sn, int *buf );

/**
 *  \brief Read "count_per_m" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_count_per_m( uint8_t sn, int *buf );

/**
 *  \brief Read "full_travel_count" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_full_travel_count( uint8_t sn, int *buf );

/**
 *  \brief Read "driver_name" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "duty_cycle" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Read "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Write "duty_cycle_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_duty_cycle_sp( uint8_t *sn, int value );

/**
 *  \brief Read "hold_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Kd( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Kd( uint8_t sn, int value );

/**
 *  \brief Write "hold_pid/Kd" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_hold_pid_Kd( uint8_t *sn, int value );

/**
 *  \brief Read "hold_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Ki( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Ki( uint8_t sn, int value );

/**
 *  \brief Write "hold_pid/Ki" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_hold_pid_Ki( uint8_t *sn, int value );

/**
 *  \brief Read "hold_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Kp( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Kp( uint8_t sn, int value );

/**
 *  \brief Write "hold_pid/Kp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_hold_pid_Kp( uint8_t *sn, int value );

/**
 *  \brief Read "max_speed" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_max_speed( uint8_t sn, int *buf );

/**
 *  \brief Read "polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_polarity( uint8_t sn, char *value );

/**
 *  \brief Write "polarity" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_polarity( uint8_t *sn, char *value );

/**
 *  \brief Read "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position( uint8_t sn, int *buf );

/**
 *  \brief Write "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position( uint8_t sn, int value );

/**
 *  \brief Write "position" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_position( uint8_t *sn, int value );

/**
 *  \brief Read "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_sp( uint8_t sn, int value );

/**
 *  \brief Write "position_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_position_sp( uint8_t *sn, int value );

/**
 *  \brief Read "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_down_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_down_sp( uint8_t sn, int value );

/**
 *  \brief Write "ramp_down_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_ramp_down_sp( uint8_t *sn, int value );

/**
 *  \brief Read "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_up_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_up_sp( uint8_t sn, int value );

/**
 *  \brief Write "ramp_up_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_ramp_up_sp( uint8_t *sn, int value );

/**
 *  \brief Read "speed" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed( uint8_t sn, int *buf );

/**
 *  \brief Read "speed_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Kd( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Kd( uint8_t sn, int value );

/**
 *  \brief Write "speed_pid/Kd" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_speed_pid_Kd( uint8_t *sn, int value );

/**
 *  \brief Read "speed_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Ki( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Ki( uint8_t sn, int value );

/**
 *  \brief Write "speed_pid/Ki" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_speed_pid_Ki( uint8_t *sn, int value );

/**
 *  \brief Read "speed_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Kp( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Kp( uint8_t sn, int value );

/**
 *  \brief Write "speed_pid/Kp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_speed_pid_Kp( uint8_t *sn, int value );

/**
 *  \brief Read "speed_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_sp( uint8_t sn, int value );

/**
 *  \brief Write "speed_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_speed_sp( uint8_t *sn, int value );

/**
 *  \brief Read "state" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "stop_action" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_action( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "stop_action" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_action( uint8_t sn, char *value );

/**
 *  \brief Write "stop_action" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_stop_action( uint8_t *sn, char *value );

/**
 *  \brief Read "stop_actions" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_actions( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_time_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_time_sp( uint8_t sn, int value );

/**
 *  \brief Write "time_sp" attribute of several tachos.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_time_sp( uint8_t *sn, int value );

/**
 *  \brief Get name of the specified tacho type.
 *  \param type_inx Index of the tacho type.
 *  \return Requested value.
 */
extern const char *ev3_tacho_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the tacho type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_tacho_type_inx( uint8_t sn );

/**
 *  \brief Read tacho attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_desc( uint8_t sn, EV3_TACHO *desc );

/**
 *  \brief Get descriptor of the tacho.
 *  \param sn Sequence number.
 *  \return Pointer to the tacho descriptor.
 */
extern EV3_TACHO *ev3_tacho_desc( uint8_t sn );

/**
 *  \brief Get type from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_tacho_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_extport( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the tacho descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_tacho_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified tacho type.
 *  \param type_inx Tacho type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the tacho by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified tacho command.
 *  \param command_inx Index of the tacho command.
 *  \return Requested value.
 */
extern const char *ev3_tacho_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the tacho by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the tacho command.
 *  \return Count of written bytes.
 */
extern size_t set_tacho_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Write "command" attribute of several tachos by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param command_inx Index of the tacho command.
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_command_inx( uint8_t *sn, INX_T command_inx );

/**
 *  \brief Get name of the specified tacho polarity.
 *  \param polarity_inx Index of the tacho polarity.
 *  \return Requested value.
 */
extern const char *ev3_tacho_polarity( INX_T polarity_inx );

/**
 *  \brief Read "polarity" attribute of the tacho and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_tacho_polarity_inx( uint8_t sn );

/**
 *  \brief Write "polarity" attribute of the tacho by the index.
 *  \param sn Sequence number.
 *  \param polarity_inx Index of the tacho polarity.
 *  \return Count of written bytes.
 */
extern size_t set_tacho_polarity_inx( uint8_t sn, INX_T polarity_inx );

/**
 *  \brief Write "polarity" attribute of several tachos by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param polarity_inx Index of the tacho polarity.
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_polarity_inx( uint8_t *sn, INX_T polarity_inx );

/**
 *  \brief Get name of the specified tacho stop_action.
 *  \param stop_action_inx Index of the tacho stop_action.
 *  \return Requested value.
 */
extern const char *ev3_tacho_stop_action( INX_T stop_action_inx );

/**
 *  \brief Read "stop_action" attribute of the tacho and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_tacho_stop_action_inx( uint8_t sn );

/**
 *  \brief Write "stop_action" attribute of the tacho by the index.
 *  \param sn Sequence number.
 *  \param stop_action_inx Index of the tacho stop_action.
 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_action_inx( uint8_t sn, INX_T stop_action_inx );

/**
 *  \brief Write "stop_action" attribute of several tachos by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param stop_action_inx Index of the tacho stop_action.
 *  \return Count of written bytes.
 */
extern size_t multi_set_tacho_stop_action_inx( uint8_t *sn, INX_T stop_action_inx );

/**
 *  \brief Read "state" attribute of the tacho and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected tachos.
 *  \return Number of found tachos or -1 in case of an error.
 */
extern int ev3_tacho_init( void );

#define DC_DIR  "/sys/class/dc-motor"  /**< Directory of DC motors. */

/**
 *  \brief Structure of a DC motor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< DC motor type. */
	uint8_t port;  /**< DC motor EV3 port. */
	uint8_t extport;  /**< DC motor extended port. */

} EV3_DC;

#define DC_DESC__LIMIT_  DESC_LIMIT  /**< Limit of DC motor descriptors. */

#define DC__NONE_  DC_DESC__LIMIT_  /**< DC motor is not found. */

/**
 *  \brief Vector of DC motor descriptors (filled by \ref ev3_dc_init).
 */
extern EV3_DC ev3_dc[ DC_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of DC motor types.
 */
enum {
	DC_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	RCX_MOTOR,

	DC_TYPE__COUNT_,  /**< Count of DC motor types. */
	DC_TYPE__UNKNOWN_ = DC_TYPE__COUNT_
};

/**
 *  \brief Common identifiers of DC motor "command" attribute.
 */
enum {
	DC_COMMAND__NONE_ = 0,

	DC_RUN_FOREVER,
	DC_RUN_TIMED,
	DC_RUN_DIRECT,
	DC_STOP,

	DC_COMMAND__COUNT_,  /**< Count of DC motor "command" attribute. */
	DC_COMMAND__UNKNOWN_ = DC_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of DC motor "polarity" attribute.
 */
enum {
	DC_POLARITY__NONE_ = 0,

	DC_NORMAL,
	DC_INVERSED,

	DC_POLARITY__COUNT_,  /**< Count of DC motor "polarity" attribute. */
	DC_POLARITY__UNKNOWN_ = DC_POLARITY__COUNT_
};

/**
 *  \brief Common identifiers of DC motor "stop_action" attribute.
 */
enum {
	DC_STOP_ACTION__NONE_ = 0,

	DC_COAST,
	DC_BRAKE,

	DC_STOP_ACTION__COUNT_,  /**< Count of DC motor "stop_action" attribute. */
	DC_STOP_ACTION__UNKNOWN_ = DC_STOP_ACTION__COUNT_
};

/**
 *  \brief Common identifiers of DC motor "state" attribute.
 */
enum {
	DC_STATE__NONE_ = 0,

	DC_RUNNING = 0x1L,
	DC_RAMPING = 0x2L,

};

/**
 *  \brief Read "address" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_address( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_command( uint8_t sn, char *value );

/**
 *  \brief Write "command" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_command( uint8_t *sn, char *value );

/**
 *  \brief Read "commands" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "driver_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "duty_cycle" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Read "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Write "duty_cycle_sp" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_duty_cycle_sp( uint8_t *sn, int value );

/**
 *  \brief Read "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_polarity( uint8_t sn, char *value );

/**
 *  \brief Write "polarity" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_polarity( uint8_t *sn, char *value );

/**
 *  \brief Read "state" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "stop_action" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_stop_action( uint8_t sn, char *value );

/**
 *  \brief Write "stop_action" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_stop_action( uint8_t *sn, char *value );

/**
 *  \brief Read "stop_actions" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_stop_actions( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "ramp_down_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_down_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_down_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_down_sp( uint8_t sn, int value );

/**
 *  \brief Write "ramp_down_sp" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_ramp_down_sp( uint8_t *sn, int value );

/**
 *  \brief Read "ramp_up_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_up_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_up_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_up_sp( uint8_t sn, int value );

/**
 *  \brief Write "ramp_up_sp" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_ramp_up_sp( uint8_t *sn, int value );

/**
 *  \brief Read "time_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_time_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "time_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_time_sp( uint8_t sn, int value );

/**
 *  \brief Write "time_sp" attribute of several DC motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_time_sp( uint8_t *sn, int value );

/**
 *  \brief Get name of the specified DC motor type.
 *  \param type_inx Index of the DC motor type.
 *  \return Requested value.
 */
extern const char *ev3_dc_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the DC motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_dc_type_inx( uint8_t sn );

/**
 *  \brief Read DC motor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_dc_desc( uint8_t sn, EV3_DC *desc );

/**
 *  \brief Get descriptor of the DC motor.
 *  \param sn Sequence number.
 *  \return Pointer to the DC motor descriptor.
 */
extern EV3_DC *ev3_dc_desc( uint8_t sn );

/**
 *  \brief Get type from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_dc_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_extport( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_dc_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified DC motor type.
 *  \param type_inx DC motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the DC motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified DC motor command.
 *  \param command_inx Index of the DC motor command.
 *  \return Requested value.
 */
extern const char *ev3_dc_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the DC motor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the DC motor command.
 *  \return Count of written bytes.
 */
extern size_t set_dc_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Write "command" attribute of several DC motors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param command_inx Index of the DC motor command.
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_command_inx( uint8_t *sn, INX_T command_inx );

/**
 *  \brief Get name of the specified DC motor polarity.
 *  \param polarity_inx Index of the DC motor polarity.
 *  \return Requested value.
 */
extern const char *ev3_dc_polarity( INX_T polarity_inx );

/**
 *  \brief Read "polarity" attribute of the DC motor and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_dc_polarity_inx( uint8_t sn );

/**
 *  \brief Write "polarity" attribute of the DC motor by the index.
 *  \param sn Sequence number.
 *  \param polarity_inx Index of the DC motor polarity.
 *  \return Count of written bytes.
 */
extern size_t set_dc_polarity_inx( uint8_t sn, INX_T polarity_inx );

/**
 *  \brief Write "polarity" attribute of several DC motors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param polarity_inx Index of the DC motor polarity.
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_polarity_inx( uint8_t *sn, INX_T polarity_inx );

/**
 *  \brief Get name of the specified DC motor stop_action.
 *  \param stop_action_inx Index of the DC motor stop_action.
 *  \return Requested value.
 */
extern const char *ev3_dc_stop_action( INX_T stop_action_inx );

/**
 *  \brief Write "stop_action" attribute of the DC motor by the index.
 *  \param sn Sequence number.
 *  \param stop_action_inx Index of the DC motor stop_action.
 *  \return Count of written bytes.
 */
extern size_t set_dc_stop_action_inx( uint8_t sn, INX_T stop_action_inx );

/**
 *  \brief Write "stop_action" attribute of several DC motors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param stop_action_inx Index of the DC motor stop_action.
 *  \return Count of written bytes.
 */
extern size_t multi_set_dc_stop_action_inx( uint8_t *sn, INX_T stop_action_inx );

/**
 *  \brief Read "state" attribute of the DC motor and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_dc_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected DC motors.
 *  \return Number of found DC motors or -1 in case of an error.
 */
extern int ev3_dc_init( void );

#define SERVO_DIR  "/sys/class/servo-motor"  /**< Directory of servo motors. */

/**
 *  \brief Structure of a servo motor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Servo motor type. */
	uint8_t port;  /**< Servo motor EV3 port. */
	uint8_t extport;  /**< Servo motor extended port. */
	uint8_t addr;  /**< Servo motor I2C address. */

} EV3_SERVO;

#define SERVO_DESC__LIMIT_  DESC_LIMIT  /**< Limit of servo motor descriptors. */

#define SERVO__NONE_  SERVO_DESC__LIMIT_  /**< Servo motor is not found. */

/**
 *  \brief Vector of servo motor descriptors (filled by \ref ev3_servo_init).
 */
extern EV3_SERVO ev3_servo[ SERVO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of servo motor types.
 */
enum {
	SERVO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	SERVO_MOTOR,

	SERVO_TYPE__COUNT_,  /**< Count of servo motor types. */
	SERVO_TYPE__UNKNOWN_ = SERVO_TYPE__COUNT_
};

/**
 *  \brief Common identifiers of servo motor "command" attribute.
 */
enum {
	SERVO_COMMAND__NONE_ = 0,

	SERVO_RUN,
	SERVO_FLOAT,

	SERVO_COMMAND__COUNT_,  /**< Count of servo motor "command" attribute. */
	SERVO_COMMAND__UNKNOWN_ = SERVO_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of servo motor "polarity" attribute.
 */
enum {
	SERVO_POLARITY__NONE_ = 0,

	SERVO_NORMAL,
	SERVO_INVERSED,

	SERVO_POLARITY__COUNT_,  /**< Count of servo motor "polarity" attribute. */
	SERVO_POLARITY__UNKNOWN_ = SERVO_POLARITY__COUNT_
};

/**
 *  \brief Common identifiers of servo motor "state" attribute.
 */
enum {
	SERVO_STATE__NONE_ = 0,

	SERVO_RUNNING = 0x1L,

};

/**
 *  \brief Read "address" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_address( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_command( uint8_t sn, char *value );

/**
 *  \brief Write "command" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_command( uint8_t *sn, char *value );

/**
 *  \brief Read "driver_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "max_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_max_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "max_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_max_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Write "max_pulse_sp" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_max_pulse_sp( uint8_t *sn, int value );

/**
 *  \brief Read "mid_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_mid_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "mid_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_mid_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Write "mid_pulse_sp" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_mid_pulse_sp( uint8_t *sn, int value );

/**
 *  \brief Read "min_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_min_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "min_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_min_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Write "min_pulse_sp" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_min_pulse_sp( uint8_t *sn, int value );

/**
 *  \brief Read "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_polarity( uint8_t sn, char *value );

/**
 *  \brief Write "polarity" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_polarity( uint8_t *sn, char *value );

/**
 *  \brief Read "position_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "position_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_position_sp( uint8_t sn, int value );

/**
 *  \brief Write "position_sp" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_position_sp( uint8_t *sn, int value );

/**
 *  \brief Read "rate_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_rate_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "rate_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_rate_sp( uint8_t sn, int value );

/**
 *  \brief Write "rate_sp" attribute of several servo motors.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_rate_sp( uint8_t *sn, int value );

/**
 *  \brief Read "state" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified servo motor type.
 *  \param type_inx Index of the servo motor type.
 *  \return Requested value.
 */
extern const char *ev3_servo_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the servo motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_servo_type_inx( uint8_t sn );

/**
 *  \brief Read servo motor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_servo_desc( uint8_t sn, EV3_SERVO *desc );

/**
 *  \brief Get descriptor of the servo motor.
 *  \param sn Sequence number.
 *  \return Pointer to the servo motor descriptor.
 */
extern EV3_SERVO *ev3_servo_desc( uint8_t sn );

/**
 *  \brief Get type from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_servo_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_extport( uint8_t sn );

/**
 *  \brief Get I2C address from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_servo_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified servo motor type.
 *  \param type_inx Servo motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the servo motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified servo motor command.
 *  \param command_inx Index of the servo motor command.
 *  \return Requested value.
 */
extern const char *ev3_servo_command( INX_T command_inx );

/**
 *  \brief Read "command" attribute of the servo motor and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_servo_command_inx( uint8_t sn );

/**
 *  \brief Write "command" attribute of the servo motor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the servo motor command.
 *  \return Count of written bytes.
 */
extern size_t set_servo_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Write "command" attribute of several servo motors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param command_inx Index of the servo motor command.
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_command_inx( uint8_t *sn, INX_T command_inx );

/**
 *  \brief Get name of the specified servo motor polarity.
 *  \param polarity_inx Index of the servo motor polarity.
 *  \return Requested value.
 */
extern const char *ev3_servo_polarity( INX_T polarity_inx );

/**
 *  \brief Read "polarity" attribute of the servo motor and get the index.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_servo_polarity_inx( uint8_t sn );

/**
 *  \brief Write "polarity" attribute of the servo motor by the index.
 *  \param sn Sequence number.
 *  \param polarity_inx Index of the servo motor polarity.
 *  \return Count of written bytes.
 */
extern size_t set_servo_polarity_inx( uint8_t sn, INX_T polarity_inx );

/**
 *  \brief Write "polarity" attribute of several servo motors by the index.
 *  \param sn Vector of sequence numbers ending with DESC_LIMIT.
 *  \param polarity_inx Index of the servo motor polarity.
 *  \return Count of written bytes.
 */
extern size_t multi_set_servo_polarity_inx( uint8_t *sn, INX_T polarity_inx );

/**
 *  \brief Read "state" attribute of the servo motor and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_servo_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected servo motors.
 *  \return Number of found servo motors or -1 in case of an error.
 */
extern int ev3_servo_init( void );

/**
 *  \brief Type of a pool of input or output sockets.
 */
typedef uint8_t POOL_T;

/**
 *  \brief Identifiers of sockets.
 */
enum {
	SOCKET__NONE_ = 0,

	IN1 = 0x1L,
	IN2 = 0x2L,
	IN3 = 0x4L,
	IN4 = 0x8L,
	OUTA = 0x10L,
	OUTB = 0x20L,
	OUTC = 0x40L,
	OUTD = 0x80L,

};

/**
 *  \brief Get socket of the EV3 port.
 *  \param port EV3 port.
 *  \return Socket.
 */
extern POOL_T port_to_socket( uint8_t port );

/**
 *  \brief Get EV3 port of the socket.
 *  \param sock Socket.
 *  \return EV3 port.
 */
extern uint8_t socket_to_port( POOL_T sock );

/**
 *  \brief Initialize the EV3 brick.
 *  \return false - the brick is NOT found or an error has occurred;
 *  true - the brick is OK.
 */
extern bool brick_init( void );

/**
 *  \brief Uninitialize the EV3 brick.
 */
extern void brick_uninit( void );

/**
 *  \brief Read state of the EV3 brick's keys.
 *  \return State.
 */
extern uint8_t brick_keys( void );

/**
 *  \brief Get value of "address" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_address( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "bin_data" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern byte *sensor_get_bin_data( POOL_T sock, byte *buf, size_t sz );

/**
 *  \brief Set value of "bin_data" attribute of sensors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Flag - success operation.
 */
extern bool sensor_set_bin_data( POOL_T pool, byte *value, size_t sz );

/**
 *  \brief Get value of "bin_data_format" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_bin_data_format( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Set value of "command" attribute of sensors.
 *  \param pool Pool of sockets.
 *  \param command_inx Index of the sensor command.
 *  \return Flag - success operation.
 */
extern bool sensor_set_command( POOL_T pool, INX_T command_inx );

/**
 *  \brief Get value of "commands" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_commands( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "direct" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_direct( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Set value of "direct" attribute of sensors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool sensor_set_direct( POOL_T pool, char *value );

/**
 *  \brief Get value of "decimals" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern dword sensor_get_decimals( POOL_T sock, dword defval );

/**
 *  \brief Get value of "driver_name" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_driver_name( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "fw_version" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_fw_version( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value (index) of "mode" attribute of the sensor.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern INX_T sensor_get_mode( POOL_T sock );

/**
 *  \brief Set value of "mode" attribute of sensors.
 *  \param pool Pool of sockets.
 *  \param mode_inx Index of the sensor mode.
 *  \return Flag - success operation.
 */
extern bool sensor_set_mode( POOL_T pool, INX_T mode_inx );

/**
 *  \brief Get value of "modes" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_modes( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "num_values" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern dword sensor_get_num_values( POOL_T sock, dword defval );

/**
 *  \brief Get value of "poll_ms" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern dword sensor_get_poll_ms( POOL_T sock, dword defval );

/**
 *  \brief Set value of "poll_ms" attribute of sensors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool sensor_set_poll_ms( POOL_T pool, dword value );

/**
 *  \brief Get value of "units" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_units( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "value0" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value0( POOL_T sock, float defval );

/**
 *  \brief Get value of "value1" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value1( POOL_T sock, float defval );

/**
 *  \brief Get value of "value2" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value2( POOL_T sock, float defval );

/**
 *  \brief Get value of "value3" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value3( POOL_T sock, float defval );

/**
 *  \brief Get value of "value4" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value4( POOL_T sock, float defval );

/**
 *  \brief Get value of "value5" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value5( POOL_T sock, float defval );

/**
 *  \brief Get value of "value6" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value6( POOL_T sock, float defval );

/**
 *  \brief Get value of "value7" attribute of the sensor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern float sensor_get_value7( POOL_T sock, float defval );

/**
 *  \brief Get value of "text_value" attribute of the sensor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *sensor_get_text_value( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "value" attribute of the sensor.
 *  \param inx Attribute index.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern int sensor_get_value( uint8_t inx, POOL_T sock, int defval );

/**
 *  \brief Set "US_DIST_CM" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_dist_cm( POOL_T pool );

/**
 *  \brief Set "US_DIST_IN" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_dist_in( POOL_T pool );

/**
 *  \brief Set "US_LISTEN" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_listen( POOL_T pool );

/**
 *  \brief Set "US_SI_CM" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_si_cm( POOL_T pool );

/**
 *  \brief Set "US_SI_IN" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_si_in( POOL_T pool );

/**
 *  \brief Set "US_DC_CM" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_dc_cm( POOL_T pool );

/**
 *  \brief Set "US_DC_IN" mode for lego_ev3_us sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool us_set_mode_us_dc_in( POOL_T pool );
					
/**
 *  \brief Set "GYRO_ANG" mode for lego_ev3_gyro sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool gyro_set_mode_gyro_ang( POOL_T pool );

/**
 *  \brief Set "GYRO_RATE" mode for lego_ev3_gyro sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool gyro_set_mode_gyro_rate( POOL_T pool );

/**
 *  \brief Set "GYRO_FAS" mode for lego_ev3_gyro sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool gyro_set_mode_gyro_fas( POOL_T pool );

/**
 *  \brief Set "GYRO_G_AND_A" mode for lego_ev3_gyro sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool gyro_set_mode_gyro_g_and_a( POOL_T pool );

/**
 *  \brief Set "GYRO_CAL" mode for lego_ev3_gyro sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool gyro_set_mode_gyro_cal( POOL_T pool );
					
/**
 *  \brief Set "COL_REFLECT" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_col_reflect( POOL_T pool );

/**
 *  \brief Set "COL_AMBIENT" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_col_ambient( POOL_T pool );

/**
 *  \brief Set "COL_COLOR" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_col_color( POOL_T pool );

/**
 *  \brief Set "REF_RAW" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_ref_raw( POOL_T pool );

/**
 *  \brief Set "RGB_RAW" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_rgb_raw( POOL_T pool );

/**
 *  \brief Set "COL_CAL" mode for lego_ev3_color sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool color_set_mode_col_cal( POOL_T pool );
					
/**
 *  \brief Set "TOUCH" mode for lego_ev3_touch sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool touch_set_mode_touch( POOL_T pool );
					
/**
 *  \brief Set "IR_PROX" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_prox( POOL_T pool );

/**
 *  \brief Set "IR_SEEK" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_seek( POOL_T pool );

/**
 *  \brief Set "IR_REMOTE" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_remote( POOL_T pool );

/**
 *  \brief Set "IR_REM_A" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_rem_a( POOL_T pool );

/**
 *  \brief Set "IR_S_ALT" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_s_alt( POOL_T pool );

/**
 *  \brief Set "IR_CAL" mode for lego_ev3_ir sensors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool ir_set_mode_ir_cal( POOL_T pool );
																																									
/**
 *  \brief Search of the specified sensor type.
 *  \param type_inx Sensor type.
 *  \return Pool of sockets to which specified sensors are plugged.
 */
extern POOL_T sensor_search( INX_T type_inx );

/**
 *  \brief Check that sensors of the specified type are plugged into specified sockets.
 *  \param pool Pool of sockets.
 *  \param type_inx Sensor type, if this parameter is `sensor)_TYPE__NONE_` the type does not matter.
 *  \return Flag - sensors are found.
 */
extern bool sensor_is_plugged( POOL_T pool, INX_T type_inx );

/**
 *  \brief Get value of "address" attribute of the tacho.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *tacho_get_address( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Set value of "command" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param command_inx Index of the tacho command.
 *  \return Flag - success operation.
 */
extern bool tacho_set_command( POOL_T pool, INX_T command_inx );

/**
 *  \brief Get value of "commands" attribute of the tacho.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *tacho_get_commands( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "count_per_rot" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_count_per_rot( POOL_T sock, int defval );

/**
 *  \brief Get value of "count_per_m" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_count_per_m( POOL_T sock, int defval );

/**
 *  \brief Get value of "full_travel_count" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_full_travel_count( POOL_T sock, int defval );

/**
 *  \brief Get value of "driver_name" attribute of the tacho.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *tacho_get_driver_name( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "duty_cycle" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_duty_cycle( POOL_T sock, int defval );

/**
 *  \brief Get value of "duty_cycle_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_duty_cycle_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "duty_cycle_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_duty_cycle_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "hold_pid/Kd" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_hold_pid_Kd( POOL_T sock, int defval );

/**
 *  \brief Set value of "hold_pid/Kd" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_hold_pid_Kd( POOL_T pool, int value );

/**
 *  \brief Get value of "hold_pid/Ki" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_hold_pid_Ki( POOL_T sock, int defval );

/**
 *  \brief Set value of "hold_pid/Ki" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_hold_pid_Ki( POOL_T pool, int value );

/**
 *  \brief Get value of "hold_pid/Kp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_hold_pid_Kp( POOL_T sock, int defval );

/**
 *  \brief Set value of "hold_pid/Kp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_hold_pid_Kp( POOL_T pool, int value );

/**
 *  \brief Get value of "max_speed" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_max_speed( POOL_T sock, int defval );

/**
 *  \brief Get value (index) of "polarity" attribute of the tacho.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern INX_T tacho_get_polarity( POOL_T sock );

/**
 *  \brief Set value of "polarity" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param polarity_inx Index of the tacho polarity.
 *  \return Flag - success operation.
 */
extern bool tacho_set_polarity( POOL_T pool, INX_T polarity_inx );

/**
 *  \brief Get value of "position" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_position( POOL_T sock, int defval );

/**
 *  \brief Set value of "position" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_position( POOL_T pool, int value );

/**
 *  \brief Get value of "position_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_position_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "position_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_position_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "ramp_down_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_ramp_down_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "ramp_down_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_ramp_down_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "ramp_up_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_ramp_up_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "ramp_up_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_ramp_up_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "speed" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_speed( POOL_T sock, int defval );

/**
 *  \brief Get value of "speed_pid/Kd" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_speed_pid_Kd( POOL_T sock, int defval );

/**
 *  \brief Set value of "speed_pid/Kd" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_speed_pid_Kd( POOL_T pool, int value );

/**
 *  \brief Get value of "speed_pid/Ki" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_speed_pid_Ki( POOL_T sock, int defval );

/**
 *  \brief Set value of "speed_pid/Ki" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_speed_pid_Ki( POOL_T pool, int value );

/**
 *  \brief Get value of "speed_pid/Kp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_speed_pid_Kp( POOL_T sock, int defval );

/**
 *  \brief Set value of "speed_pid/Kp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_speed_pid_Kp( POOL_T pool, int value );

/**
 *  \brief Get value of "speed_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_speed_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "speed_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_speed_sp( POOL_T pool, int value );

/**
 *  \brief Get value (flags) of "state" attribute of the tacho.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern FLAGS_T tacho_get_state( POOL_T sock );

/**
 *  \brief Get value (index) of "stop_action" attribute of the tacho.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern INX_T tacho_get_stop_action( POOL_T sock );

/**
 *  \brief Set value of "stop_action" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param stop_action_inx Index of the tacho stop_action.
 *  \return Flag - success operation.
 */
extern bool tacho_set_stop_action( POOL_T pool, INX_T stop_action_inx );

/**
 *  \brief Get value of "stop_actions" attribute of the tacho.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *tacho_get_stop_actions( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "time_sp" attribute of the tacho.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int tacho_get_time_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "time_sp" attribute of tachos.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool tacho_set_time_sp( POOL_T pool, int value );

/**
 *  \brief Set "run_forever" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_run_forever( POOL_T pool );

/**
 *  \brief Set "run_to_abs_pos" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_run_to_abs_pos( POOL_T pool );

/**
 *  \brief Set "run_to_rel_pos" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_run_to_rel_pos( POOL_T pool );

/**
 *  \brief Set "run_timed" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_run_timed( POOL_T pool );

/**
 *  \brief Set "run_direct" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_run_direct( POOL_T pool );

/**
 *  \brief Set "stop" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_stop( POOL_T pool );

/**
 *  \brief Set "reset" command for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_reset( POOL_T pool );
	
/**
 *  \brief Set "normal" polarity for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_set_polarity_normal( POOL_T pool );

/**
 *  \brief Set "inversed" polarity for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_set_polarity_inversed( POOL_T pool );
	
/**
 *  \brief Set "coast" stop_action for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_set_stop_action_coast( POOL_T pool );

/**
 *  \brief Set "brake" stop_action for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_set_stop_action_brake( POOL_T pool );

/**
 *  \brief Set "hold" stop_action for tachos.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool tacho_set_stop_action_hold( POOL_T pool );

/**
 *  \brief Search of the specified tacho type.
 *  \param type_inx Tacho type.
 *  \return Pool of sockets to which specified tachos are plugged.
 */
extern POOL_T tacho_search( INX_T type_inx );

/**
 *  \brief Check that tachos of the specified type are plugged into specified sockets.
 *  \param pool Pool of sockets.
 *  \param type_inx Tacho type, if this parameter is `tacho)_TYPE__NONE_` the type does not matter.
 *  \return Flag - tachos are found.
 */
extern bool tacho_is_plugged( POOL_T pool, INX_T type_inx );

/**
 *  \brief Check that tachos are running.
 *  \param pool Pool of sockets.
 *  \return Flag - at least one tacho is running.
 */
extern bool tacho_is_running( POOL_T pool );

/**
 *  \brief Get value of "address" attribute of the DC motor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *dc_get_address( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Set value of "command" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param command_inx Index of the DC motor command.
 *  \return Flag - success operation.
 */
extern bool dc_set_command( POOL_T pool, INX_T command_inx );

/**
 *  \brief Get value of "commands" attribute of the DC motor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *dc_get_commands( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "driver_name" attribute of the DC motor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *dc_get_driver_name( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "duty_cycle" attribute of the DC motor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int dc_get_duty_cycle( POOL_T sock, int defval );

/**
 *  \brief Get value of "duty_cycle_sp" attribute of the DC motor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int dc_get_duty_cycle_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "duty_cycle_sp" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool dc_set_duty_cycle_sp( POOL_T pool, int value );

/**
 *  \brief Get value (index) of "polarity" attribute of the DC motor.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern INX_T dc_get_polarity( POOL_T sock );

/**
 *  \brief Set value of "polarity" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param polarity_inx Index of the DC motor polarity.
 *  \return Flag - success operation.
 */
extern bool dc_set_polarity( POOL_T pool, INX_T polarity_inx );

/**
 *  \brief Get value (flags) of "state" attribute of the DC motor.
 *  \param sock Socket.
 *  \return Requested value.
 */
extern FLAGS_T dc_get_state( POOL_T sock );

/**
 *  \brief Set value of "stop_action" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param stop_action_inx Index of the DC motor stop_action.
 *  \return Flag - success operation.
 */
extern bool dc_set_stop_action( POOL_T pool, INX_T stop_action_inx );

/**
 *  \brief Get value of "stop_actions" attribute of the DC motor.
 *  \param sock Socket.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Requested value.
 */
extern char *dc_get_stop_actions( POOL_T sock, char *buf, size_t sz );

/**
 *  \brief Get value of "ramp_down_sp" attribute of the DC motor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int dc_get_ramp_down_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "ramp_down_sp" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool dc_set_ramp_down_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "ramp_up_sp" attribute of the DC motor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int dc_get_ramp_up_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "ramp_up_sp" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool dc_set_ramp_up_sp( POOL_T pool, int value );

/**
 *  \brief Get value of "time_sp" attribute of the DC motor.
 *  \param sock Socket.
 *  \param defval Default value.
 *  \return Requested value.
 */
extern int dc_get_time_sp( POOL_T sock, int defval );

/**
 *  \brief Set value of "time_sp" attribute of DC motors.
 *  \param pool Pool of sockets.
 *  \param value Attribute value.
			 
 *  \return Flag - success operation.
 */
extern bool dc_set_time_sp( POOL_T pool, int value );

/**
 *  \brief Set "run_forever" command for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_run_forever( POOL_T pool );

/**
 *  \brief Set "run_timed" command for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_run_timed( POOL_T pool );

/**
 *  \brief Set "run_direct" command for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_run_direct( POOL_T pool );

/**
 *  \brief Set "stop" command for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_stop( POOL_T pool );
	
/**
 *  \brief Set "normal" polarity for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_set_polarity_normal( POOL_T pool );

/**
 *  \brief Set "inversed" polarity for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_set_polarity_inversed( POOL_T pool );
	
/**
 *  \brief Set "coast" stop_action for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_set_stop_action_coast( POOL_T pool );

/**
 *  \brief Set "brake" stop_action for DC motors.
 *  \param pool Pool of sockets.
 *  \return Flag - success operation.
 */
extern bool dc_set_stop_action_brake( POOL_T pool );

/**
 *  \brief Search of the specified DC motor type.
 *  \param type_inx DC motor type.
 *  \return Pool of sockets to which specified DC motors are plugged.
 */
extern POOL_T dc_search( INX_T type_inx );

/**
 *  \brief Check that DC motors of the specified type are plugged into specified sockets.
 *  \param pool Pool of sockets.
 *  \param type_inx DC motor type, if this parameter is `dc)_TYPE__NONE_` the type does not matter.
 *  \return Flag - DC motors are found.
 */
extern bool dc_is_plugged( POOL_T pool, INX_T type_inx );

/**
 *  \brief Check that DC motors are running.
 *  \param pool Pool of sockets.
 *  \return Flag - at least one DC motor is running.
 */
extern bool dc_is_running( POOL_T pool );

/**
 *  \brief Delay in milliseconds.
 *  \param ms Value.
 */
extern void sleep_ms( uint32_t ms );

