($import "app.yu")
($TITLE,,Main page of docs.)

/** \mainpage ($DESCRIPTION)

\htmlinclude mainpage.style

<center>
\verbatim
 
 ____ __     ____   ___    ____ __         (((((()
| |_  \ \  /   ) ) | |  ) | |_  \ \  /  \(@)- /   
|_|__  \_\/  __)_) |_|_/  |_|__  \_\/   /(@)- \   
                                           ((())))
 
\endverbatim
</center>

## [($LIBRARY)](https://github.com/in4lio/ev3dev-c/) ($VERSION) (for kernel ($KERNEL))

## The library hierarchic structure

### Low-level

Low level contains functions for \ref ev3 "local" and \ref ev3_link "remote" access to the file system of
the EV3 brick. The following code will write `"heartbeat"` string to the specified file (if running on the brick)
or will send both of the arguments to the brick using UDP message (if running on the remote computer).

\code {.c}
ev3_init();
ev3_write( "/sys/class/leds/ev3:red:right/trigger", "heartbeat" );
ev3_uninit();
\endcode

See also – \ref io.c

<p>For more information about remote access to the brick, please, read
["ev3_link"](https://github.com/in4lio/ev3dev-c/tree/master/source/ev3/ev3_link).

### Mid-level

Mid-level provides the performance optimized library that is intended to cover all main functionality of "ev3dev".

To start working with the library, you have to call the library initialization `ev3_init()` which will connect
to the brick over network if your program is running on a remote computer, then, to detect devices plugged
to the brick, please call initialization for each of the necessary class of devices, e.g. `ev3_tacho_init()`.
Do not forget to call `ev3_uninit()` at the program end.

All functions to access the device's attributes require the sequence number of device `sn`.
You can find the sequence number in the descriptor table, which was filled during initialization,
e.g. <tt>\ref ev3_search_tacho "ev3_search_tacho(LEGO_EV3_L_MOTOR, &sn, 0)"</tt>.

Access to some frequently used string attributes can be performed by the index, for example,
you can just check the mode index:
\code {.c}
( get_sensor_mode_inx( sn ) == IR_IR_PROX )
\endcode
instead of string comparison:
\code {.c}
( get_sensor_mode( sn, buf, sizeof( buf )) && ( strcmp( buf, "IR-PROX" ) == 0 ))
\endcode

See comprehensive example based on coroutines – \ref drive.c

A few more examples:

&bull; Using \ref ev3_led "LEDs", see ["Using LEDs"](https://github.com/ev3dev/ev3dev/wiki/Using-the-LEDs):

\code {.c}
int ok;
uint8_t val;

ev3_init();
ok = get_led_brightness( EV3_GREEN_LEFT, &val );
if ( ok ) {
	printf( "EV3_GREEN_LEFT is %s\n", ( val ) ? "ON" : "OFF" );
}
ev3_uninit();
\endcode

See also – \ref rcx_led.c

&bull; Using \ref ev3_sensor "sensors", see
["LEGO Sensor Class"](http://www.ev3dev.org/docs/drivers/lego-sensor-class/):

\code {.c}
uint8_t sn;
int val;

ev3_init();
if ( ev3_search_sensor( LEGO_EV3_TOUCH, &sn, 0 )) {
	if ( get_sensor_value( 0, sn, &val )) {
		printf( "TOUCH sensor value = %d\n", val );
	}
}
ev3_uninit();
\endcode

See also – \ref sensor.c

&bull; Using \ref ev3_tacho "tacho motors", see
["Tacho Motor Class"](http://www.ev3dev.org/docs/drivers/tacho-motor-class/):

\code {.c}
uint8_t sn;

ev3_init();
ev3_tacho_init();
if ( ev3_search_tacho( LEGO_EV3_L_MOTOR, &sn, 0 )) {
	set_tacho_stop_action_inx( sn, TACHO_BRAKE );
	set_tacho_speed_sp( sn, 500 );
	set_tacho_time_sp( sn, 5000 );
	set_tacho_ramp_up_sp( sn, 2000 );
	set_tacho_ramp_down_sp( sn, 2000 );
	set_tacho_command( sn, "run_timed" );
}
ev3_uninit();
\endcode

See also - \ref tacho.c

&bull; Using \ref ev3_dc "DC motors", see ["DC Motor Class"](http://www.ev3dev.org/docs/drivers/dc-motor-class/):

\code {.c}
uint8_t sn, sn_port;

ev3_init();
ev3_port_init();
sn_port = ev3_search_port( OUTPUT_D, EXT_PORT__NONE_ );
set_port_mode_inx( sn_port, OUTPUT_DC_MOTOR );

ev3_dc_init();
if ( ev3_search_dc_plugged_in( OUTPUT_D, EXT_PORT__NONE_, &sn, 0 )) {
	set_dc_duty_cycle_sp( sn, 100 );
	set_dc_command_inx( sn, DC_RUN_FOREVER );
	usleep( 5000000 );
	set_dc_command_inx( sn, DC_STOP );
}
set_port_mode_inx( sn_port, OUTPUT_AUTO );
ev3_uninit();
\endcode

See also - \ref dc.c

&bull; Using \ref ev3_servo "servo motors", see
["Servo Motor Class"](http://www.ev3dev.org/docs/drivers/servo-motor-class/):

\code {.c}
uint8_t sn, sn_port;

ev3_init();
ev3_port_init();
sn_port = ev3_search_port( INPUT_1, EXT_PORT__NONE_ );
set_port_mode_inx( sn_port, INPUT_NXT_ANALOG );
set_port_set_device( sn_port, ( char *) ev3_sensor_type( MS_8CH_SERVO ));

ev3_servo_init();
if ( ev3_search_servo_plugged_in( INPUT_1, EXT_PORT__NONE_, 1, &sn, 0 )) {
	set_servo_command_inx( sn, SERVO_RUN );
	set_servo_position_sp( sn, 100 );
}
set_port_mode_inx( sn_port, INPUT_AUTO );
ev3_uninit();
\endcode

See also – \ref servo.c

&bull; Using \ref ev3_port "EV3 ports", see
["Input and Output Ports"](http://www.ev3dev.org/docs/ports/):

\code {.c}
uint8_t sn;
char s[ 256 ];

ev3_init();
ev3_port_init();
sn = ev3_search_port( INPUT_2, EXT_PORT__NONE_ );
if ( get_port_mode( sn, s, sizeof( s ))) {
4	printf( "INPUT_2 mode = %s\n", s );
}
ev3_uninit();
\endcode

See also – \ref port.c

&bull; Using \ref ev3_port "EV3 extended ports":

\code {.c}
uint8_t sn, sn_port;
int val;

ev3_init();
ev3_port_init();
sn_port = ev3_search_port( INPUT_1, HT_NXT_SMUX_PORT_2 );
set_port_mode_inx( sn_port, INPUT_NXT_ANALOG );
set_port_set_device( sn_port, ( char *) ev3_sensor_type( LEGO_NXT_TOUCH ));

ev3_sensor_init();
if ( ev3_search_sensor_plugged_in( INPUT_1, HT_NXT_SMUX_PORT_2, &sn, 0 )) {
	if ( get_sensor_value( 0, sn, &val )) {
		printf( "TOUCH sensor value = %d\n", val );
	}
}
set_port_mode_inx( sn_port, INPUT_AUTO );
ev3_uninit();
\endcode

&bull; Using \ref ev3_read_keys "keys" of the EV3 brick:

\code {.c}
uint8_t val;

ev3_init();
do ev3_read_keys( &val ); while (( val & EV3_KEY_BACK ) == 0 );
ev3_uninit();
\endcode

### High-level

\ref brick is a simplified interface of "ev3dev-c". We use a mask of sockets (ports)
instead of sequence numbers for access to devices, it allows to set identical attributes
of several devices concurrently, but extended ports are not supported.

See example of using "brick" library, based on coroutines – \ref remote.c

A few more examples:

&bull; Using \ref brick :

\code {.c}
brick_init();
if ( tacho_is_plugged(  OUTB | OUTC, LEGO_EV3_L_MOTOR )) {
	tacho_set_speed_sp( OUTB | OUTC, tacho_get_max_speed( OUTB, 0 ) * 0.75 );  // 75%
	tacho_run_forever(  OUTB | OUTC );
	sleep_ms( 3000 );  // 3 sec
	tacho_stop( OUTB );
	sleep_ms( 2000 );  // 2 sec
	tacho_stop( OUTC );
}
brick_uninit();
\endcode

&bull; Using \ref ev3_light "light" module:

\code {.c}
ev3_init();
set_light_blink( LIT_LEFT, LIT_AMBER, 1000, 500 );
ev3_uninit();
\endcode

See also – \ref light.c


## Python, Ruby, Perl and other languages

The libraries for [Python](https://pypi.python.org/pypi/ev3dev-c/), Ruby and Perl have been generated
using [SWIG](http://www.swig.org/).
The SWIG interface file `ev3.i` is generated out of [`ev3.yu-i`](https://github.com/in4lio/ev3dev-c/blob/master/ev3.yu-i).

#### Features of Python library:

1. The functions return the requested value as the second element of the result tuple;
2. Access to the descriptors of detected devices only through `ev3_<class>_desc` or
`ev3_<class>_desc_<field>` functions (e.g. \ref ev3_sensor_desc, \ref ev3_port_desc);
3. Access to the global variables through `ev3` namespace.

\code {.py}
color = [ '?', 'BLACK', 'BLUE', 'GREEN', 'YELLOW', 'RED', 'WHITE', 'BROWN' ]

if not EV3_BRICK:
    ev3.brick_addr = '192.168.0.244'
ev3_init()
ev3_sensor_init()
ok, sn = ev3_search_sensor( LEGO_EV3_UART_29 )
if ok:
    set_sensor_mode( sn, 'COL-COLOR' )

    ok, val = get_sensor_value( 0, sn )
    if ok:
        print 'COLOR =', color[ val ]
ev3_uninit()
\endcode

Using \ref brick with Python:

\code {.py}
brick_init()
if tacho_is_plugged( OUTB | OUTC, LEGO_EV3_L_MOTOR ):
	tacho_set_speed_sp( OUTB | OUTC, tacho_get_max_speed( OUTB ) * 0.75 )  # 75%
	tacho_run_forever( OUTB | OUTC )
	sleep_ms( 3000 )  # 3 sec
	tacho_stop( OUTB )
	sleep_ms( 2000 )  # 2 sec
	tacho_stop( OUTC )

brick_uninit()
\endcode

See also – [Examples in Python](https://github.com/in4lio/ev3dev-c/blob/master/python/ev3dev/eg)

#### Features of Ruby library:

1. The functions return the requested value as the second element of the result tuple,
the first element has a boolean type;
2. Access to the descriptors of detected devices only through `ev3_<class>_desc` or
`ev3_<class>_desc_<field>` functions (e.g. \ref ev3_dc_desc, \ref ev3_dc_desc_port).

\code {.py}
include Ev3

ev3_init()
ev3_sensor_init()
ok, sn = ev3_search_sensor( LEGO_EV3_TOUCH )
if ok
  while get_sensor_value( 0, sn )[ 1 ] == 0 do end
end
ev3_uninit()
\endcode

See also – [Examples in Ruby](https://github.com/in4lio/ev3dev-c/blob/master/ruby/eg)

#### Features of Perl library:

1. The functions return the requested value as the second element of the result tuple;
2. Access to the descriptors of detected devices only through `ev3_<class>_desc_<field>` functions
(e.g. \ref ev3_tacho_desc_type_inx, \ref ev3_tacho_desc_port).

\code {.c}
use ev3;

ev3::ev3_init();
ev3::ev3_tacho_init();
my ( $ok, $sn ) = ev3::ev3_search_tacho( $ev3::LEGO_EV3_M_MOTOR );
if ( $ok ) {
    ev3::set_tacho_speed_sp( $sn, 500 );
    ev3::set_tacho_command_inx( $sn, $ev3::TACHO_RUN_FOREVER );
    sleep( 2 );
    ev3::set_tacho_command_inx( $sn, $ev3::TACHO_STOP );
}
ev3::ev3_uninit();
\endcode

See also – \ref [Examples in Perl](https://github.com/in4lio/ev3dev-c/blob/master/perl/eg)

Similarly you can use SWIG to wrap the library in a number of other languages.


\example drive.c
\example remote.c
\example light.c
\example sensor.c
\example tacho.c
\example tacho.cpp
\example dc.c
\example servo.c
\example rcx_led.c
\example port.c
\example io.c
\example poweroff.c
\example hello.c

\example remote.py
\example light.py
\example sensor.py
\example tacho.py
\example dc.py
\example led.py
\example port.py
\example io.py
\example poweroff.py

\example light.rb
\example sensor.rb
\example tacho.rb
\example led.rb
\example io.rb
\example poweroff.rb

\example light.pl
\example sensor.pl
\example tacho.pl
\example led.pl
\example io.pl
\example poweroff.pl

*/
