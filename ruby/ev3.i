
/*  ev3.i was generated by yup.py (yupp) 0.7b7
    out of ev3.yu-i at 2014-11-26 13:24
 *//**
 *  \file  ev3.i (ev3.yu-i)
 *  \brief  SWIG interface file.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

%module ev3
%include "cstring.i"
%include "stdint.i"
%include "typemaps.i"

%{
#include "../source/ev3/ev3.h"
#include "../source/ev3/ev3_led.h"
#include "../source/ev3/ev3_light.h"
#include "../source/ev3/ev3_output.h"
#include "../source/ev3/ev3_input.h"
#include "../source/ev3/nxt_input_mux.h"
#include "../source/ev3/ev3_port.h"
#include "../source/ev3/ev3_sensor.h"
#include "../source/ev3/ev3_tacho.h"
#include "../source/ev3/ev3_dc.h"
#include "../source/ev3/ev3_servo.h"
#include "../source/ev3/nxt_analog_host.h"
%}

/* Unfortunately incompatible with %typemap( default ) size_t sz { $1 = DEFAULT_BUF_SIZE; } */
%cstring_output_maxsize( char *buf, size_t sz );

%include "./platform.h"

#ifdef SWIGPERL
/* because of the problem with SWIG_From_bool on the brick... */
#define bool  int

#endif

%apply bool *OUTPUT { bool *buf };
%apply int *OUTPUT { int *buf };
%apply uint8_t *OUTPUT { uint8_t *buf };
%apply uint8_t *OUTPUT { byte *buf };
%apply uint8_t *OUTPUT { uint8_t *extport };
%apply uint8_t *OUTPUT { uint8_t *sn };
%apply uint32_t *OUTPUT { uint32_t *buf };
%apply uint32_t *OUTPUT { dword *buf };
%apply float *OUTPUT { float *buf };

%apply uint32_t { dword };
%apply uint8_t { byte };

#ifdef SWIGRUBY
%typemap( out ) size_t, bool { $result = $1 ? Qtrue : Qfalse; };
%typemap( in ) bool { $1 = $input == Qtrue ? 1 : 0; };

#endif

%typemap( default ) uint8_t from { $1 = 0; }

/*
 *  ev3
 */

// CLIENT ////////////////////////////////////////
#if EV3_BRICK == 0

%rename( brick_addr ) ev3_brick_addr;
extern char *ev3_brick_addr;
%rename( brick_port ) ev3_brick_port;
extern uint16_t ev3_brick_port;

//////////////////////////////////////////////////
#endif

extern int ev3_init( void );
extern void ev3_uninit( void );

extern size_t ev3_write_binary( const char *fn, char *STRING, size_t LENGTH );
extern size_t ev3_write( const char *fn, char *value );
extern size_t ev3_write_bool( const char *fn, bool value );
extern size_t ev3_write_int( const char *fn, int value );
extern size_t ev3_write_dword( const char *fn, uint32_t value );
extern size_t ev3_write_byte( const char *fn, uint8_t value );
extern size_t ev3_write_float( const char *fn, float value );

extern size_t ev3_read_binary( const char *fn, char *buf, size_t sz );
extern size_t ev3_read( const char *fn, char *buf, size_t sz );

#ifndef SWIGRUBY
extern size_t ev3_read_bool( const char *fn, bool *buf );

#endif
extern size_t ev3_read_int( const char *fn, int *buf );
extern size_t ev3_read_dword( const char *fn, uint32_t *buf );
extern size_t ev3_read_byte( const char *fn, uint8_t *buf );
extern size_t ev3_read_float( const char *fn, float *buf );

extern size_t ev3_listdir( const char *fn, char *buf, size_t sz );
extern bool ev3_poweroff( void );

/**
 *  \brief Identifiers of LEDs.
 */
enum {
	EV3_GREEN_LEFT,
	EV3_GREEN_RIGHT,
	EV3_RED_LEFT,
	EV3_RED_RIGHT,
	EV3_LED_OUTA,
	EV3_LED_OUTB,
	EV3_LED_OUTC,
	EV3_LED_OUTD,

	LED__COUNT_  /**< Count of EV3 LEDs. */
};

/**
 *  \brief Triggers identifiers of LEDs.
 */
enum {
	TRIGGER_NONE,
	TRIGGER_MMC0,
	TRIGGER_TIMER,
	TRIGGER_HEARTBEAT,
	TRIGGER_DEFAULT_ON,
	TRIGGER_TRANSIENT,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING,
	TRIGGER_LEGOEV3_BATTERY_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID,
	TRIGGER_RFKILL0,
	TRIGGER_PHY0RX,
	TRIGGER_PHY0TX,
	TRIGGER_PHY0ASSOC,
	TRIGGER_PHY0RADIO,
	TRIGGER_RFKILL1,

	TRIGGER__COUNT_  /**< Count of EV3 triggers. */
};

#define LED_ATTR__COUNT_ 5

/**
 *  \brief Get "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_led_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Set "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_brightness( uint8_t inx, byte value );

/**
 *  \brief Get "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_led_delay_off( uint8_t inx, int *buf );

/**
 *  \brief Set "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_off( uint8_t inx, int value );

/**
 *  \brief Get "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_led_delay_on( uint8_t inx, int *buf );

/**
 *  \brief Set "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_on( uint8_t inx, int value );

/**
 *  \brief Get "max_brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_led_max_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Get "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_led_trigger( uint8_t inx, char *buf, size_t sz );

/**
 *  \brief Set "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger( uint8_t inx, char *value );

/**
 *  \brief Get the trigger index of the LED.
 *  \param inx Index of the LED.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_led_trigger_inx( uint8_t inx );

/**
 *  \brief Set the trigger of the LED by index.
 *  \param inx Index of the LED.
 *  \param trigger_inx Index of trigger.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger_inx( uint8_t inx, uint8_t trigger_inx );

/**
 *  \brief Get name of the specified LED trigger.
 *  \param trigger_inx Index of trigger.
 *  \return Requested value.
 */
extern const char *ev3_led_trigger( uint8_t trigger_inx );

#define LED_DIR  "/sys/class/leds"  /**< Directory of LEDs. */

/**
 *  \brief Identifiers of light locations.
 */
enum {
	LIT_LEFT,
	LIT_RIGHT,

	LIT__LOC__
};

/**
 *  \brief Identifiers of light colors.
 */
enum {
	LIT_OFF,
	LIT_GREEN,
	LIT_RED,
	LIT_AMBER,

	LIT__COL__
};

/**
 *  \brief Light colors.
 */
extern const char * const LIT_COLOR[] = { "OFF", "GREEN", "RED", "AMBER", STR_unknown_ };

/**
 *  \brief Set the light color.
 *  \param loc Location.
 *  \param col Color.
 */
extern void set_light( uint8_t loc, uint8_t col );

/**
 *  \brief Get the light color.
 *  \param loc Location.
 *  \return Color.
 */
extern uint8_t get_light( uint8_t loc );

/**
 *  \brief Set the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \param trigger Index of trigger.
 */
extern void set_light_trigger( uint8_t loc, uint8_t col, uint8_t trigger );

/**
 *  \brief Get the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_light_trigger( uint8_t loc, uint8_t col );

/**
 *  \brief Set the light blink.
 *  \param loc Location.
 *  \param col Color.
 *  \param delay_on Time of "on" state in ms.
 *  \param delay_off Time of "off" state in ms.
 */
extern void set_light_blink( uint8_t loc, uint8_t col, int delay_on, int delay_off );

/**
 *  \brief Check the light is blinking.
 *  \param loc Location.
 *  \param col Color.
 *  \return Flag - the light is blinking.
 */
extern bool get_light_blink( uint8_t loc, uint8_t col );

#define OUTPUT_DIR  "/sys/bus/legoev3/devices"  /**< Directory of output ports. */
#define OUTPUT__BASE_  128  /**< Base index of EV3 output ports. */

/**
 *  \brief Identifiers of EV3 output ports.
 */
enum {
	OUTPUT_A = OUTPUT__BASE_ + 0,
	OUTPUT_B = OUTPUT__BASE_ + 1,
	OUTPUT_C = OUTPUT__BASE_ + 2,
	OUTPUT_D = OUTPUT__BASE_ + 3,

};

#define OUTPUT__COUNT_  4  /**< Count of EV3 output ports. */

/**
 *  \brief Identifiers of output port modes.
 */
enum {
	OUTPUT_AUTO,
	OUTPUT_EV3_TACHO_MOTOR,
	OUTPUT_RCX_MOTOR,
	OUTPUT_RCX_LED,
	OUTPUT_RAW,

	OUTPUT_MODE__COUNT_  /**< Count of output port modes. */
};

/**
 *  \brief Get index of the EV3 output port from the port name.
 *  \param name Port name.
 *  \return EV3 output port index.
 */
extern uint8_t ev3_output_inx( const char *name );

/**
 *  \brief Get name of the specified EV3 output port.
 *  \param port Port index.
 *  \return Requested value.
 */
extern const char *ev3_output_name( uint8_t port );

/**
 *  \brief Get "mode" attribute of the output port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_output_mode( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the output port.
 *  \param port Port index.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_output_mode( uint8_t port, char *value );

/**
 *  \brief Get "modes" attribute of the output port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_output_modes( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Get "pin5_mv" attribute of the output port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_output_pin5_mv( uint8_t port, int *buf );

/**
 *  \brief Get "state" attribute of the output port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_output_state( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Get name of the specified output mode.
 *  \param mode_inx The output mode.
 *  \return Requested value.
 */
extern const char *ev3_output_mode( uint8_t mode_inx );

/**
 *  \brief Get the mode index of the output port.
 *  \param port Port index.
 *  \return Index of the mode or OUTPUT_MODE__COUNT_ - error has occurred.
 */
extern uint8_t get_output_mode_inx( uint8_t port );

/**
 *  \brief Set the mode of the output by index.
 *  \param port Port index.
 *  \param mode_inx Index of the mode.
 *  \return Count of written bytes.
 */
extern size_t set_output_mode_inx( uint8_t port, uint8_t mode_inx );

#define INPUT_DIR  "/sys/bus/legoev3/devices"  /**< Directory of input ports. */
#define INPUT__BASE_  1  /**< Base index of EV3 input ports. */

/**
 *  \brief Identifiers of EV3 input ports.
 */
enum {
	INPUT_1 = INPUT__BASE_ + 0,
	INPUT_2 = INPUT__BASE_ + 1,
	INPUT_3 = INPUT__BASE_ + 2,
	INPUT_4 = INPUT__BASE_ + 3,

};

#define INPUT__COUNT_  4  /**< Count of EV3 input ports. */

/**
 *  \brief Identifiers of input port modes.
 */
enum {
	INPUT_AUTO,
	INPUT_EV3_ANALOG,
	INPUT_EV3_UART,
	INPUT_NXT_ANALOG,
	INPUT_NXT_COLOR,
	INPUT_NXT_I2C,
	INPUT_OTHER_UART,
	INPUT_RAW,

	INPUT_MODE__COUNT_  /**< Count of input port modes. */
};

/**
 *  \brief Get index of the EV3 input port from the port name.
 *  \param name Port name.
 *  \return EV3 input port index.
 */
extern uint8_t ev3_input_inx( const char *name );

/**
 *  \brief Get name of the specified EV3 input port.
 *  \param port Port index.
 *  \return Requested value.
 */
extern const char *ev3_input_name( uint8_t port );

/**
 *  \brief Get "mode" attribute of the input port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_input_mode( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the input port.
 *  \param port Port index.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_input_mode( uint8_t port, char *value );

/**
 *  \brief Get "modes" attribute of the input port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_input_modes( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Get "pin1_mv" attribute of the input port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_input_pin1_mv( uint8_t port, int *buf );

/**
 *  \brief Get "pin6_mv" attribute of the input port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_input_pin6_mv( uint8_t port, int *buf );

/**
 *  \brief Get "state" attribute of the input port.
 *  \param port Port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_input_state( uint8_t port, char *buf, size_t sz );

/**
 *  \brief Get name of the specified input mode.
 *  \param mode_inx The input mode.
 *  \return Requested value.
 */
extern const char *ev3_input_mode( uint8_t mode_inx );

/**
 *  \brief Get the mode index of the input port.
 *  \param port Port index.
 *  \return Index of the mode or INPUT_MODE__COUNT_ - error has occurred.
 */
extern uint8_t get_input_mode_inx( uint8_t port );

/**
 *  \brief Set the mode of the input by index.
 *  \param port Port index.
 *  \param mode_inx Index of the mode.
 *  \return Count of written bytes.
 */
extern size_t set_input_mode_inx( uint8_t port, uint8_t mode_inx );

/**
 *  \brief Identifiers of multiplexer input ports.
 */
enum {
	INPUT_MUX__NONE_,
	INPUT_MUX_1,
	INPUT_MUX_2,
	INPUT_MUX_3,
	INPUT_MUX_4,

};

#define INPUT_MUX__BASE_  1  /**< Base index of multiplexer ports. */
#define INPUT_MUX__COUNT_  4  /**< Count of multiplexer ports. */

/**
 *  \brief Identifiers of multiplexer port modes.
 */
enum {
	INPUT_MUX_ANALOG,
	INPUT_MUX_I2C,

	INPUT_MUX_MODE__COUNT_  /**< Count of multiplexer port modes. */
};

/**
 *  \brief Get indexes of the EV3 input port and the extended port from the multiplexer port name.
 *  \param name Port name.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 input port index.
 */
extern uint8_t nxt_input_mux_inx( const char *name, uint8_t *extport );

/**
 *  \brief Get name of the specified multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \return Requested value.
 */
extern const char *nxt_input_mux_name( uint8_t port, uint8_t extport );

/**
 *  \brief Get "mode" attribute of the multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_input_mux_mode( uint8_t port, uint8_t extport, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_input_mux_mode( uint8_t port, uint8_t extport, char *value );

/**
 *  \brief Get "modes" attribute of the multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_input_mux_modes( uint8_t port, uint8_t extport, char *buf, size_t sz );

/**
 *  \brief Get name of the specified multiplexer port mode.
 *  \param mode_inx Index of the multiplexer port mode.
 *  \return Requested value.
 */
extern const char *nxt_input_mux_mode( uint8_t mode_inx );

/**
 *  \brief Get the mode index of the multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \return Index of the mode or INPUT_MUX_MODE__COUNT_ - error has occurred.
 */
extern uint8_t get_input_mux_mode_inx( uint8_t port, uint8_t extport );

/**
 *  \brief Set the mode of the multiplexer port by index.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param mode_inx Index of the mode.
 *  \return Count of written bytes.
 */
extern size_t set_input_mux_mode_inx( uint8_t port, uint8_t extport, uint8_t mode_inx );

/**
 *  \brief Undefined EV3 port.
 */
#define EV3_PORT__NONE_  0

/**
 *  \brief Get indexes of the EV3 port and the extended port from the port name.
 *  \param name Port name.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t ev3_port_inx( const char *name, uint8_t *extport );

/**
 *  \brief Get name of the specified EV3 port or multiplexer port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \return Requested value.
 */
extern const char *ev3_port_name( uint8_t port, uint8_t extport );

#define SENSOR_DIR  "/sys/class/msensor"  /**< Directory of sensors. */

/**
 *  \brief Structure of a sensor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Sensor type. */
	uint8_t port;  /**< Sensor EV3 port. */
	uint8_t extport;  /**< Sensor extended port. */
	uint8_t addr;  /**< Sensor address. */

} EV3_SENSOR;

#define SENSOR_DESC__LIMIT_  64  /**< Limit of sensor descriptors. */

#define SENSOR__NONE_  SENSOR_DESC__LIMIT_  /**< Sensor is not found. */

/**
 *  \brief Vector of sensor descriptors (filled by \ref ev3_sensor_init).
 */
extern EV3_SENSOR ev3_sensor[ SENSOR_DESC__LIMIT_ ];

/**
 *  \brief Types of sensors.
 */
enum {
	SENSOR_TYPE__NONE_ = 0,

	EV3_ANALOG_XX,
	NXT_ANALOG,
	HT_NXT_COLOR,
	HT_NXT_ANGLE,
	HT_NXT_ACCEL,
	HT_NXT_BAROMETRIC,
	HT_NXT_COLOR_V2,
	HT_NXT_EOPD,
	HT_NXT_FORCE,
	HT_NXT_GYRO,
	HT_NXT_IR_LINK,
	HT_NXT_IR_RECEIVER,
	HT_NXT_PIR,
	HT_NXT_COMPASS,
	HT_NXT_MAG,
	HT_NXT_IR_SEEKER_V2,
	HT_NXT_SMUX,
	HT_SUPER_PRO,
	EV3_UART_30,
	EV3_UART_32,
	EV3_UART_29,
	LEGO_EV3_TOUCH,
	EV3_UART_33,
	WEDO_MOTION,
	WEDO_TILT,
	LEGO_POWER_STORAGE,
	LEGO_NXT_TOUCH,
	LEGO_NXT_LIGHT,
	LEGO_NXT_SOUND,
	LEGO_NXT_US,
	MI_XG1300L,
	MS_ABSOLUTE_IMU,
	MS_ANGLE,
	MS_LIGHT_ARRAY,
	MS_8CH_SERVO,
	MS_NXT_TOUCH_MUX,

	SENSOR_TYPE__COUNT_
};

/**
 *  \brief Get "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz );

/**
 *  \brief Set "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz );

/**
 *  \brief Get "bin_data_format" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_sensor_command( uint8_t sn, char *value );

/**
 *  \brief Get "commands" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "dp" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_dp( uint8_t sn, dword *buf );

/**
 *  \brief Get "fw_version" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "address" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_address( uint8_t sn, byte *buf );

/**
 *  \brief Get "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode( uint8_t sn, char *value );

/**
 *  \brief Get "modes" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "num_values" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_num_values( uint8_t sn, dword *buf );

/**
 *  \brief Get "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_poll_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_sensor_poll_ms( uint8_t sn, dword value );

/**
 *  \brief Get "port_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "units" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_units( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "value0" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value0( uint8_t sn, float *buf );

/**
 *  \brief Get "value1" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value1( uint8_t sn, float *buf );

/**
 *  \brief Get "value2" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value2( uint8_t sn, float *buf );

/**
 *  \brief Get "value3" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value3( uint8_t sn, float *buf );

/**
 *  \brief Get "value4" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value4( uint8_t sn, float *buf );

/**
 *  \brief Get "value5" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value5( uint8_t sn, float *buf );

/**
 *  \brief Get "value6" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value6( uint8_t sn, float *buf );

/**
 *  \brief Get "value7" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value7( uint8_t sn, float *buf );

/**
 *  \brief Get "value" attribute of the sensor.
 *  \param inx Attribute index.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf );

/**
 *  \brief Get name of the specified sensor type.
 *  \param type_inx The sensor type.
 *  \return Requested value.
 */
extern const char *ev3_sensor_type( uint8_t type_inx );

/**
 *  \brief Get index of the sensor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_sensor_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the sensor.
 *  \param sn Sequence number.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_sensor_port_inx( uint8_t sn, uint8_t *extport );

/**
 *  \brief Get descriptor of the sensor.
 *  \param sn Sequence number.
 *  \return Pointer to the sensor descriptor.
 */
extern EV3_SENSOR *ev3_sensor_desc( uint8_t sn );

/**
 *  \brief Get type from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_extport( uint8_t sn );
/**
 *  \brief Get address from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_addr( uint8_t sn );

/**
 *  \brief Search of the specified sensor type.
 *  \param type_inx The sensor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of the sensor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param addr Address.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t addr, uint8_t *sn, uint8_t from );

/**
 *  \brief Detect connected sensors.
 *  \return The number of found sensors or -1 in case of an error.
 */
extern int ev3_sensor_init( void );

#define TACHO_DIR  "/sys/class/tacho-motor"  /**< Directory of tachos. */

/**
 *  \brief Structure of a tacho descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Tacho type. */
	uint8_t port;  /**< Tacho EV3 port. */
	uint8_t extport;  /**< Tacho extended port. */

} EV3_TACHO;

#define TACHO_DESC__LIMIT_  64  /**< Limit of tacho descriptors. */

#define TACHO__NONE_  TACHO_DESC__LIMIT_  /**< Tacho is not found. */

/**
 *  \brief Vector of tacho descriptors (filled by \ref ev3_tacho_init).
 */
extern EV3_TACHO ev3_tacho[ TACHO_DESC__LIMIT_ ];

/**
 *  \brief Types of tachos.
 */
enum {
	TACHO_TYPE__NONE_ = 0,

	TACHO,
	MINITACHO,

	TACHO_TYPE__COUNT_
};

/**
 *  \brief Get "duty_cycle" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Get "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Get "polarity_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_polarity_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "port_name" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_position( uint8_t sn, int *buf );

/**
 *  \brief Set "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_position( uint8_t sn, int value );

/**
 *  \brief Get "position_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "position_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_mode( uint8_t sn, char *value );

/**
 *  \brief Get "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_sp( uint8_t sn, int value );

/**
 *  \brief Get "pulses_per_second" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_pulses_per_second( uint8_t sn, int *buf );

/**
 *  \brief Get "pulses_per_second_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_pulses_per_second_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "pulses_per_second_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_pulses_per_second_sp( uint8_t sn, int value );

/**
 *  \brief Get "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_down_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_down_sp( uint8_t sn, dword value );

/**
 *  \brief Get "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_up_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_up_sp( uint8_t sn, dword value );

/**
 *  \brief Get "regulation_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_regulation_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "regulation_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_regulation_mode( uint8_t sn, char *value );

/**
 *  \brief Set "reset" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_reset( uint8_t sn, bool value );

/**
 *  \brief Get "run" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_run( uint8_t sn, bool *buf );

/**
 *  \brief Set "run" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_run( uint8_t sn, bool value );

/**
 *  \brief Get "run_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_run_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "run_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_run_mode( uint8_t sn, char *value );

/**
 *  \brief Get "speed_regulation_D" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_D( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_D" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_D( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_I" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_I( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_I" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_I( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_K" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_K( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_K" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_K( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_P" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_P( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_P" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_P( uint8_t sn, int value );

/**
 *  \brief Get "state" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "stop_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "stop_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_mode( uint8_t sn, char *value );

/**
 *  \brief Get "stop_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_tacho_time_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_tacho_time_sp( uint8_t sn, dword value );

/**
 *  \brief Get "type" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_type( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified tacho type.
 *  \param type_inx The tacho type.
 *  \return Requested value.
 */
extern const char *ev3_tacho_type( uint8_t type_inx );

/**
 *  \brief Get index of the tacho type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_tacho_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the tacho.
 *  \param sn Sequence number.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_tacho_port_inx( uint8_t sn, uint8_t *extport );

/**
 *  \brief Get descriptor of the tacho.
 *  \param sn Sequence number.
 *  \return Pointer to the tacho descriptor.
 */
extern EV3_TACHO *ev3_tacho_desc( uint8_t sn );

/**
 *  \brief Get type from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_extport( uint8_t sn );

/**
 *  \brief Search of the specified tacho type.
 *  \param type_inx The tacho type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of the tacho by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.

 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Detect connected tachos.
 *  \return The number of found tachos or -1 in case of an error.
 */
extern int ev3_tacho_init( void );

#define DC_DIR  "/sys/class/dc-motor"  /**< Directory of DC motors. */

/**
 *  \brief Structure of a DC motor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< DC motor type. */
	uint8_t port;  /**< DC motor EV3 port. */
	uint8_t extport;  /**< DC motor extended port. */

} EV3_DC;

#define DC_DESC__LIMIT_  64  /**< Limit of DC motor descriptors. */

#define DC__NONE_  DC_DESC__LIMIT_  /**< DC motor is not found. */

/**
 *  \brief Vector of DC motor descriptors (filled by \ref ev3_dc_init).
 */
extern EV3_DC ev3_dc[ DC_DESC__LIMIT_ ];

/**
 *  \brief Types of DC motors.
 */
enum {
	DC_TYPE__NONE_ = 0,

	RCX_MOTOR,

	DC_TYPE__COUNT_
};

/**
 *  \brief Get "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_dc_command( uint8_t sn, char *value );

/**
 *  \brief Get "commands" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "duty_cycle" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Get "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_dc_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Get "name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_dc_polarity( uint8_t sn, char *value );

/**
 *  \brief Get "port_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "ramp_down_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_down_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_down_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_down_ms( uint8_t sn, dword value );

/**
 *  \brief Get "ramp_up_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_up_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_up_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_up_ms( uint8_t sn, dword value );

/**
 *  \brief Get name of the specified DC motor type.
 *  \param type_inx The DC motor type.
 *  \return Requested value.
 */
extern const char *ev3_dc_type( uint8_t type_inx );

/**
 *  \brief Get index of the DC motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_dc_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the DC motor.
 *  \param sn Sequence number.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_dc_port_inx( uint8_t sn, uint8_t *extport );

/**
 *  \brief Get descriptor of the DC motor.
 *  \param sn Sequence number.
 *  \return Pointer to the DC motor descriptor.
 */
extern EV3_DC *ev3_dc_desc( uint8_t sn );

/**
 *  \brief Get type from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_extport( uint8_t sn );

/**
 *  \brief Search of the specified DC motor type.
 *  \param type_inx The DC motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of the DC motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.

 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Detect connected DC motors.
 *  \return The number of found DC motors or -1 in case of an error.
 */
extern int ev3_dc_init( void );

#define SERVO_DIR  "/sys/class/servo-motor"  /**< Directory of servo motors. */

/**
 *  \brief Structure of a servo motor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Servo motor type. */
	uint8_t port;  /**< Servo motor EV3 port. */
	uint8_t extport;  /**< Servo motor extended port. */
	uint8_t addr;  /**< Servo motor channel. */

} EV3_SERVO;

#define SERVO_DESC__LIMIT_  64  /**< Limit of servo motor descriptors. */

#define SERVO__NONE_  SERVO_DESC__LIMIT_  /**< Servo motor is not found. */

/**
 *  \brief Vector of servo motor descriptors (filled by \ref ev3_servo_init).
 */
extern EV3_SERVO ev3_servo[ SERVO_DESC__LIMIT_ ];

/**
 *  \brief Types of servo motors.
 */
enum {
	SERVO_TYPE__NONE_ = 0,

	SERVO_MOTOR,

	SERVO_TYPE__COUNT_
};

/**
 *  \brief Get "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_command( uint8_t sn, char *value );

/**
 *  \brief Get "max_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_servo_max_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "max_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_max_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "mid_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_servo_mid_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "mid_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_mid_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "min_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_servo_min_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "min_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_min_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_polarity( uint8_t sn, char *value );

/**
 *  \brief Get "port_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "position" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_servo_position( uint8_t sn, int *buf );

/**
 *  \brief Set "position" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_position( uint8_t sn, int value );

/**
 *  \brief Get "rate" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.

 *  \return Count of read bytes.
 */
extern size_t get_servo_rate( uint8_t sn, dword *buf );

/**
 *  \brief Set "rate" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_servo_rate( uint8_t sn, dword value );

/**
 *  \brief Get name of the specified servo motor type.
 *  \param type_inx The servo motor type.
 *  \return Requested value.
 */
extern const char *ev3_servo_type( uint8_t type_inx );

/**
 *  \brief Get index of the servo motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_servo_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the servo motor.
 *  \param sn Sequence number.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_servo_port_inx( uint8_t sn, uint8_t *extport );

/**
 *  \brief Get descriptor of the servo motor.
 *  \param sn Sequence number.
 *  \return Pointer to the servo motor descriptor.
 */
extern EV3_SERVO *ev3_servo_desc( uint8_t sn );

/**
 *  \brief Get type from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_extport( uint8_t sn );
/**
 *  \brief Get channel from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_addr( uint8_t sn );

/**
 *  \brief Search of the specified servo motor type.
 *  \param type_inx The servo motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of the servo motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param addr Address.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo_plugged_in( uint8_t port, uint8_t extport, uint8_t addr, uint8_t *sn, uint8_t from );

/**
 *  \brief Detect connected servo motors.
 *  \return The number of found servo motors or -1 in case of an error.
 */
extern int ev3_servo_init( void );

/**
 *  \brief Get the channel of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Count of read bytes.
 */
extern size_t get_servo_address( uint8_t sn, uint8_t *buf );

/**
 *  \brief Get name of the specified servo motor port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param addr Servo motor channel.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 */
extern void ev3_servo_port_name( uint8_t port, uint8_t extport, uint8_t addr, char *buf, size_t sz );

#define NXT_ANALOG_HOST_DIR  "/sys/bus/legoev3/devices"  /**< Directory of nxt-analog-host drivers. */

/**
 *  \brief Get "device_type" attribute of the nxt-analog-host driver.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_nxt_analog_host_device_type( uint8_t port, uint8_t extport, char *buf, size_t sz );

/**
 *  \brief Get "port_name" attribute of the nxt-analog-host driver.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_nxt_analog_host_port_name( uint8_t port, uint8_t extport, char *buf, size_t sz );

/**
 *  \brief Set "set_sensor" attribute of the nxt-analog-host driver.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param value Attribute value.

 *  \return Count of written bytes.
 */
extern size_t set_nxt_analog_host_set_sensor( uint8_t port, uint8_t extport, char *value );

