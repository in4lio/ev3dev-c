
/*  ev3.i was generated by yup.py (yupp) 0.8b2
    out of ev3.yu-i at 2015-03-03 19:38
 *//**
 *  \file  ev3.i (ev3.yu-i)
 *  \brief  SWIG interface file.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

%module ev3
%include "cstring.i"
%include "stdint.i"
%include "typemaps.i"

%{
#include "../source/ev3/ev3.h"
#include "../source/ev3/ev3_led.h"
#include "../source/ev3/ev3_light.h"
#include "../source/ev3/ev3_port.h"
#include "../source/ev3/ev3_sensor.h"
#include "../source/ev3/ev3_tacho.h"
#include "../source/ev3/ev3_dc.h"
#include "../source/ev3/ev3_servo.h"
%}

/* Unfortunately incompatible with %typemap( default ) size_t sz { $1 = DEFAULT_BUF_SIZE; } */
%cstring_output_maxsize( char *buf, size_t sz );

%include "./platform.h"

#ifdef SWIGPERL
/* because of the problem with SWIG_From_bool on the brick... */
#define bool  int

#endif

%apply bool *OUTPUT { bool *buf };
%apply int *OUTPUT { int *buf };
%apply uint8_t *OUTPUT { uint8_t *buf };
%apply uint8_t *OUTPUT { byte *buf };
%apply uint8_t *OUTPUT { uint8_t *extport };
%apply uint8_t *OUTPUT { uint8_t *sn };
%apply uint32_t *OUTPUT { uint32_t *buf };
%apply uint32_t *OUTPUT { dword *buf };
%apply float *OUTPUT { float *buf };

%apply uint32_t { dword };
%apply uint8_t { byte };

#ifdef SWIGRUBY
%typemap( out ) size_t, bool { $result = $1 ? Qtrue : Qfalse; };
%typemap( in ) bool { $1 = $input == Qtrue ? 1 : 0; };

#endif

%typemap( default ) uint8_t from { $1 = 0; }

/*
 *  ev3
 */

// CLIENT ////////////////////////////////////////
#if EV3_BRICK == 0

%rename( brick_addr ) ev3_brick_addr;
extern char *ev3_brick_addr;
%rename( brick_port ) ev3_brick_port;
extern uint16_t ev3_brick_port;

//////////////////////////////////////////////////
#endif

extern int ev3_init( void );
extern void ev3_uninit( void );

extern size_t ev3_write_binary( const char *fn, char *STRING, size_t LENGTH );
extern size_t ev3_write( const char *fn, char *value );
extern size_t ev3_write_bool( const char *fn, bool value );
extern size_t ev3_write_int( const char *fn, int value );
extern size_t ev3_write_dword( const char *fn, uint32_t value );
extern size_t ev3_write_byte( const char *fn, uint8_t value );
extern size_t ev3_write_float( const char *fn, float value );

extern size_t ev3_read_binary( const char *fn, char *buf, size_t sz );
extern size_t ev3_read( const char *fn, char *buf, size_t sz );

#ifndef SWIGRUBY
extern size_t ev3_read_bool( const char *fn, bool *buf );

#endif
extern size_t ev3_read_int( const char *fn, int *buf );
extern size_t ev3_read_dword( const char *fn, uint32_t *buf );
extern size_t ev3_read_byte( const char *fn, uint8_t *buf );
extern size_t ev3_read_float( const char *fn, float *buf );

extern size_t ev3_listdir( const char *fn, char *buf, size_t sz );
extern bool ev3_poweroff( void );

/**
 *  \brief Identifiers of LEDs.
 */
enum {
	EV3_GREEN_LEFT,
	EV3_GREEN_RIGHT,
	EV3_RED_LEFT,
	EV3_RED_RIGHT,
	EV3_LED_OUTA,
	EV3_LED_OUTB,
	EV3_LED_OUTC,
	EV3_LED_OUTD,

	LED__COUNT_  /**< Count of EV3 LEDs. */
};

/**
 *  \brief Triggers identifiers of LEDs.
 */
enum {
	TRIGGER_NONE,
	TRIGGER_MMC0,
	TRIGGER_TIMER,
	TRIGGER_HEARTBEAT,
	TRIGGER_DEFAULT_ON,
	TRIGGER_TRANSIENT,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING,
	TRIGGER_LEGOEV3_BATTERY_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID,
	TRIGGER_RFKILL0,
	TRIGGER_PHY0RX,
	TRIGGER_PHY0TX,
	TRIGGER_PHY0ASSOC,
	TRIGGER_PHY0RADIO,
	TRIGGER_RFKILL1,

	TRIGGER__COUNT_  /**< Count of EV3 triggers. */
};

#define LED_ATTR__COUNT_ 5

/**
 *  \brief Get "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Set "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_brightness( uint8_t inx, byte value );

/**
 *  \brief Get "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_off( uint8_t inx, int *buf );

/**
 *  \brief Set "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_off( uint8_t inx, int value );

/**
 *  \brief Get "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_on( uint8_t inx, int *buf );

/**
 *  \brief Set "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_on( uint8_t inx, int value );

/**
 *  \brief Get "max_brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_max_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Get "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_led_trigger( uint8_t inx, char *buf, size_t sz );

/**
 *  \brief Set "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger( uint8_t inx, char *value );

/**
 *  \brief Get the trigger index of the LED.
 *  \param inx Index of the LED.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_led_trigger_inx( uint8_t inx );

/**
 *  \brief Set the trigger of the LED by index.
 *  \param inx Index of the LED.
 *  \param trigger_inx Index of the trigger.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger_inx( uint8_t inx, uint8_t trigger_inx );

/**
 *  \brief Get name of the specified LED trigger.
 *  \param trigger_inx Index of the trigger.
 *  \return Requested value.
 */
extern const char *ev3_led_trigger( uint8_t trigger_inx );

/**
 *  \brief Identifiers of light locations.
 */
enum {
	LIT_LEFT,
	LIT_RIGHT,

	LIT__LOC__
};

/**
 *  \brief Identifiers of light colors.
 */
enum {
	LIT_OFF,
	LIT_GREEN,
	LIT_RED,
	LIT_AMBER,

	LIT__COL__
};

/**
 *  \brief Light colors.
 */
extern const char * const LIT_COLOR[] = { "OFF", "GREEN", "RED", "AMBER", STR_unknown_ };

/**
 *  \brief Set the light color.
 *  \param loc Location.
 *  \param col Color.
 */
extern void set_light( uint8_t loc, uint8_t col );

/**
 *  \brief Get the light color.
 *  \param loc Location.
 *  \return Color.
 */
extern uint8_t get_light( uint8_t loc );

/**
 *  \brief Set the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \param trigger Index of trigger.
 */
extern void set_light_trigger( uint8_t loc, uint8_t col, uint8_t trigger );

/**
 *  \brief Get the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_light_trigger( uint8_t loc, uint8_t col );

/**
 *  \brief Set the light blink.
 *  \param loc Location.
 *  \param col Color.
 *  \param delay_on Time of "on" state in ms.
 *  \param delay_off Time of "off" state in ms.
 */
extern void set_light_blink( uint8_t loc, uint8_t col, int delay_on, int delay_off );

/**
 *  \brief Check the light is blinking.
 *  \param loc Location.
 *  \param col Color.
 *  \return Flag - the light is blinking.
 */
extern bool get_light_blink( uint8_t loc, uint8_t col );

#define PORT_DIR  "/sys/class/lego-port"  /**< Directory of EV3 ports. */

/**
 *  \brief Structure of a EV3 port descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< EV3 port type. */
	uint8_t port;  /**< EV3 port EV3 port. */
	uint8_t extport;  /**< EV3 port extended port. */

} EV3_PORT;

#define PORT_DESC__LIMIT_  64  /**< Limit of EV3 port descriptors. */

#define PORT__NONE_  PORT_DESC__LIMIT_  /**< EV3 port is not found. */

/**
 *  \brief Vector of EV3 port descriptors (filled by \ref ev3_port_init).
 */
extern EV3_PORT ev3_port[ PORT_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of EV3 port types.
 */
enum {
	PORT_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	HT_NXT_SMUX_PORT,
	LEGOEV3_INPUT_PORT,
	LEGOEV3_OUTPUT_PORT,
	MS_EV3_SMUX_PORT,
	WEDO_PORT,

	PORT_TYPE__COUNT_,  /**< Count of EV3 port types. */
	PORT_TYPE__UNKNOWN_ = PORT_TYPE__COUNT_
};

/**
 *  \brief Identifiers of EV3 port modes.
 */
enum {
	PORT_MODE__NONE_ = 0,

	HT_NXT_SMUX_PORT_ANALOG,
	HT_NXT_SMUX_PORT_I2C,

	LEGOEV3_INPUT_PORT_AUTO,
	LEGOEV3_INPUT_PORT_NXT_ANALOG,
	LEGOEV3_INPUT_PORT_NXT_COLOR,
	LEGOEV3_INPUT_PORT_NXT_I2C,
	LEGOEV3_INPUT_PORT_EV3_ANALOG,
	LEGOEV3_INPUT_PORT_EV3_UART,
	LEGOEV3_INPUT_PORT_OTHER_UART,
	LEGOEV3_INPUT_PORT_RAW,

	LEGOEV3_OUTPUT_PORT_AUTO,
	LEGOEV3_OUTPUT_PORT_EV3_TACHO_MOTOR,
	LEGOEV3_OUTPUT_PORT_RCX_MOTOR,
	LEGOEV3_OUTPUT_PORT_RCX_LED,
	LEGOEV3_OUTPUT_PORT_RAW,

	MS_EV3_SMUX_PORT_UART,
	MS_EV3_SMUX_PORT_ANALOG,

	WEDO_PORT_AUTO,

	PORT_MODE__COUNT_,  /**< Count of EV3 port modes. */
	PORT_MODE__UNKNOWN_ = PORT_MODE__COUNT_
};

/**
 *  \brief Get "driver_name" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_mode( uint8_t sn, char *value );

/**
 *  \brief Get "modes" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "port_name" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "set_device" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_set_device( uint8_t sn, char *value );

/**
 *  \brief Get "status" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_status( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified EV3 port type.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern const char *ev3_port_type( uint8_t type_inx );

/**
 *  \brief Get index of the EV3 port type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_port_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the EV3 port.
 *  \param sn Sequence number.
 *  \param port_type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_port_port_inx( uint8_t sn, uint8_t port_type_inx, uint8_t *extport );

/**
 *  \brief Get descriptor of the EV3 port.
 *  \param sn Sequence number.
 *  \return Pointer to the EV3 port descriptor.
 */
extern EV3_PORT *ev3_port_desc( uint8_t sn );

/**
 *  \brief Get type from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_extport( uint8_t sn );

/**
 *  \brief Search of a sequence number of the specified EV3 port type.
 *  \param type_inx The EV3 port type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_type( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the EV3 port by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified EV3 port mode.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Requested value.
 */
extern const char *ev3_port_mode( uint8_t mode_inx );

/**
 *  \brief Get index of the EV3 port mode.
 *  \param sn Sequence number.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern uint8_t get_port_mode_inx( uint8_t sn, uint8_t type_inx );

/**
 *  \brief Set mode of the EV3 port by index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Count of written bytes.
 */
extern size_t set_port_mode_inx( uint8_t sn, uint8_t mode_inx );

/**
 *  \brief Detect connected EV3 ports.
 *  \return The number of found EV3 ports or -1 in case of an error.
 */
extern int ev3_port_init( void );

/**
 *  \brief Identifiers of EV3 ports and extended ports.
 */
enum {
	EV3_PORT__NONE_ = 0,  /* XXX: memset( 0 ) is used */
	EXT_PORT__NONE_ = EV3_PORT__NONE_,

	HT_NXT_SMUX_PORT__BASE_,
					
	HT_NXT_SMUX_PORT_1 = HT_NXT_SMUX_PORT__BASE_ + 0,
			
	HT_NXT_SMUX_PORT_2 = HT_NXT_SMUX_PORT__BASE_ + 1,
			
	HT_NXT_SMUX_PORT_3 = HT_NXT_SMUX_PORT__BASE_ + 2,
			
	HT_NXT_SMUX_PORT_4 = HT_NXT_SMUX_PORT__BASE_ + 3,
			
	LEGOEV3_INPUT_PORT__BASE_,
					
	LEGOEV3_INPUT_PORT_1 = LEGOEV3_INPUT_PORT__BASE_ + 0,
	INPUT_1 = LEGOEV3_INPUT_PORT_1,
			
	LEGOEV3_INPUT_PORT_2 = LEGOEV3_INPUT_PORT__BASE_ + 1,
	INPUT_2 = LEGOEV3_INPUT_PORT_2,
			
	LEGOEV3_INPUT_PORT_3 = LEGOEV3_INPUT_PORT__BASE_ + 2,
	INPUT_3 = LEGOEV3_INPUT_PORT_3,
			
	LEGOEV3_INPUT_PORT_4 = LEGOEV3_INPUT_PORT__BASE_ + 3,
	INPUT_4 = LEGOEV3_INPUT_PORT_4,

	LEGOEV3_OUTPUT_PORT__BASE_,
					
	LEGOEV3_OUTPUT_PORT_A = LEGOEV3_OUTPUT_PORT__BASE_ + 0,
	OUTPUT_A = LEGOEV3_OUTPUT_PORT_A,
			
	LEGOEV3_OUTPUT_PORT_B = LEGOEV3_OUTPUT_PORT__BASE_ + 1,
	OUTPUT_B = LEGOEV3_OUTPUT_PORT_B,
			
	LEGOEV3_OUTPUT_PORT_C = LEGOEV3_OUTPUT_PORT__BASE_ + 2,
	OUTPUT_C = LEGOEV3_OUTPUT_PORT_C,
			
	LEGOEV3_OUTPUT_PORT_D = LEGOEV3_OUTPUT_PORT__BASE_ + 3,
	OUTPUT_D = LEGOEV3_OUTPUT_PORT_D,

	MS_EV3_SMUX_PORT__BASE_,
					
	MS_EV3_SMUX_PORT_1 = MS_EV3_SMUX_PORT__BASE_ + 0,
			
	MS_EV3_SMUX_PORT_2 = MS_EV3_SMUX_PORT__BASE_ + 1,
			
	MS_EV3_SMUX_PORT_3 = MS_EV3_SMUX_PORT__BASE_ + 2,
			
	MS_EV3_SMUX_PORT_4 = MS_EV3_SMUX_PORT__BASE_ + 3,
			
	WEDO_PORT__BASE_,
					
	WEDO_PORT_1 = WEDO_PORT__BASE_ + 0,
			
	WEDO_PORT_2 = WEDO_PORT__BASE_ + 1,
			
	WEDO_PORT_3 = WEDO_PORT__BASE_ + 2,
			
	WEDO_PORT_4 = WEDO_PORT__BASE_ + 3,
			
};

#define INPUT_AUTO  LEGOEV3_INPUT_PORT_AUTO
#define INPUT_NXT_ANALOG  LEGOEV3_INPUT_PORT_NXT_ANALOG
#define INPUT_NXT_COLOR  LEGOEV3_INPUT_PORT_NXT_COLOR
#define INPUT_NXT_I2C  LEGOEV3_INPUT_PORT_NXT_I2C
#define INPUT_EV3_ANALOG  LEGOEV3_INPUT_PORT_EV3_ANALOG
#define INPUT_EV3_UART  LEGOEV3_INPUT_PORT_EV3_UART
#define INPUT_OTHER_UART  LEGOEV3_INPUT_PORT_OTHER_UART
#define INPUT_RAW  LEGOEV3_INPUT_PORT_RAW

#define OUTPUT_AUTO  LEGOEV3_OUTPUT_PORT_AUTO
#define OUTPUT_EV3_TACHO_MOTOR  LEGOEV3_OUTPUT_PORT_EV3_TACHO_MOTOR
#define OUTPUT_RCX_MOTOR  LEGOEV3_OUTPUT_PORT_RCX_MOTOR
#define OUTPUT_RCX_LED  LEGOEV3_OUTPUT_PORT_RCX_LED
#define OUTPUT_RAW  LEGOEV3_OUTPUT_PORT_RAW

/**
 *  \brief Count of ht-nxt-smux-ports.
 */
#define HT_NXT_SMUX_PORT__COUNT_  4

/**
 *  \brief Count of legoev3-input-ports.
 */
#define LEGOEV3_INPUT_PORT__COUNT_  4

/**
 *  \brief Count of legoev3-output-ports.
 */
#define LEGOEV3_OUTPUT_PORT__COUNT_  4

/**
 *  \brief Count of ms-ev3-smux-ports.
 */
#define MS_EV3_SMUX_PORT__COUNT_  4

/**
 *  \brief Count of wedo-ports.
 */
#define WEDO_PORT__COUNT_  4

/**
 *  \brief Search of a port sequence number by the EV3 port and the extended port.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \return Port sequence number.
 */
extern uint8_t ev3_search_port( uint8_t port, uint8_t extport );

/**
 *  \brief Get indexes of the EV3 port and the extended port from the port name.
 *  \param name Port name.
 *  \param type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t ev3_port_inx( uint8_t type_inx, const char *name, uint8_t *extport );

/**
 *  \brief Get name of the specified port.
 *  \param port EV3 port index.
 *  \param extport Extended port index.
 *  \return Requested value.
 */
extern const char *ev3_port_name( uint8_t port, uint8_t extport );

#define SENSOR_DIR  "/sys/class/lego-sensor"  /**< Directory of sensors. */

/**
 *  \brief Structure of a sensor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Sensor type. */
	uint8_t port;  /**< Sensor EV3 port. */
	uint8_t extport;  /**< Sensor extended port. */
	uint8_t addr;  /**< Sensor address. */

} EV3_SENSOR;

#define SENSOR_DESC__LIMIT_  64  /**< Limit of sensor descriptors. */

#define SENSOR__NONE_  SENSOR_DESC__LIMIT_  /**< Sensor is not found. */

/**
 *  \brief Vector of sensor descriptors (filled by \ref ev3_sensor_init).
 */
extern EV3_SENSOR ev3_sensor[ SENSOR_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of sensor types.
 */
enum {
	SENSOR_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	EV3_ANALOG_XX,
	NXT_ANALOG,
	HT_NXT_COLOR,
	HT_NXT_ANGLE,
	HT_NXT_ACCEL,
	HT_NXT_BAROMETRIC,
	HT_NXT_COLOR_V2,
	HT_NXT_EOPD,
	HT_NXT_FORCE,
	HT_NXT_GYRO,
	HT_NXT_IR_LINK,
	HT_NXT_IR_RECEIVER,
	HT_NXT_PIR,
	HT_NXT_COMPASS,
	HT_NXT_MAG,
	HT_NXT_IR_SEEK_V2,
	HT_NXT_SMUX,
	HT_SUPER_PRO,
	LEGO_EV3_UART_30,
	LEGO_EV3_UART_32,
	LEGO_EV3_UART_29,
	LEGO_EV3_TOUCH,
	LEGO_EV3_UART_33,
	WEDO_HUB,
	WEDO_MOTION,
	WEDO_TILT,
	LEGO_POWER_STORAGE,
	LEGO_NXT_TOUCH,
	LEGO_NXT_LIGHT,
	LEGO_NXT_SOUND,
	LEGO_NXT_US,
	MI_XG1300L,
	MS_ABSOLUTE_IMU,
	MS_ANGLE,
	MS_EV3_SMUX,
	MS_LIGHT_ARRAY,
	MS_LINE_LEADER,
	MS_8CH_SERVO,
	MS_NXT_TOUCH_MUX,

	SENSOR_TYPE__COUNT_,  /**< Count of sensor types. */
	SENSOR_TYPE__UNKNOWN_ = SENSOR_TYPE__COUNT_
};

/**
 *  \brief Identifiers of sensor modes.
 */
enum {
	SENSOR_MODE__NONE_ = 0,

	EV3_ANALOG_XX_ANALOG,

	NXT_ANALOG_ANALOG_0,
	NXT_ANALOG_ANALOG_1,

	HT_NXT_COLOR_COLOR,
	HT_NXT_COLOR_RED,
	HT_NXT_COLOR_GREEN,
	HT_NXT_COLOR_BLUE,
	HT_NXT_COLOR_RAW,
	HT_NXT_COLOR_NORM,
	HT_NXT_COLOR_ALL,

	HT_NXT_ANGLE_ANGLE,
	HT_NXT_ANGLE_ACCEL,
	HT_NXT_ANGLE_SPEED,

	HT_NXT_ACCEL_ACCEL,
	HT_NXT_ACCEL_ALL,

	HT_NXT_BAROMETRIC_PRESS,
	HT_NXT_BAROMETRIC_TEMP,

	HT_NXT_COLOR_V2_COLOR,
	HT_NXT_COLOR_V2_RED,
	HT_NXT_COLOR_V2_GREEN,
	HT_NXT_COLOR_V2_BLUE,
	HT_NXT_COLOR_V2_WHITE,
	HT_NXT_COLOR_V2_NORM,
	HT_NXT_COLOR_V2_ALL,
	HT_NXT_COLOR_V2_RAW,

	HT_NXT_EOPD_LONG,
	HT_NXT_EOPD_SHORT,

	HT_NXT_FORCE_FORCE,

	HT_NXT_GYRO_GYRO,

	HT_NXT_IR_LINK_IRLINK,

	HT_NXT_IR_RECEIVER_1_MOTOR,
	HT_NXT_IR_RECEIVER_8_MOTOR,

	HT_NXT_PIR_PROX,

	HT_NXT_COMPASS_COMPASS,

	HT_NXT_MAG_MAG,

	HT_NXT_IR_SEEK_V2_DC,
	HT_NXT_IR_SEEK_V2_AC,
	HT_NXT_IR_SEEK_V2_DC_ALL,
	HT_NXT_IR_SEEK_V2_AC_ALL,

	HT_NXT_SMUX_MUX,

	HT_SUPER_PRO_AIN,
	HT_SUPER_PRO_DIN,
	HT_SUPER_PRO_DOUT,
	HT_SUPER_PRO_DCTRL,
	HT_SUPER_PRO_STROBE,
	HT_SUPER_PRO_LED,
	HT_SUPER_PRO_AOUT_0,
	HT_SUPER_PRO_AOUT_1,

	LEGO_EV3_UART_30_US_DIST_CM,
	LEGO_EV3_UART_30_US_DIST_IN,
	LEGO_EV3_UART_30_US_LISTEN,
	LEGO_EV3_UART_30_US_SI_CM,
	LEGO_EV3_UART_30_US_SI_IN,
	LEGO_EV3_UART_30_US_DC_CM,
	LEGO_EV3_UART_30_US_DC_IN,

	LEGO_EV3_UART_32_GYRO_ANG,
	LEGO_EV3_UART_32_GYRO_RATE,
	LEGO_EV3_UART_32_GYRO_FAS,
	LEGO_EV3_UART_32_GYRO_G_AND_A,
	LEGO_EV3_UART_32_GYRO_CAL,

	LEGO_EV3_UART_29_COL_REFLECT,
	LEGO_EV3_UART_29_COL_AMBIENT,
	LEGO_EV3_UART_29_COL_COLOR,
	LEGO_EV3_UART_29_REF_RAW,
	LEGO_EV3_UART_29_RGB_RAW,
	LEGO_EV3_UART_29_COL_CAL,

	LEGO_EV3_TOUCH_TOUCH,

	LEGO_EV3_UART_33_IR_PROX,
	LEGO_EV3_UART_33_IR_SEEK,
	LEGO_EV3_UART_33_IR_REMOTE,
	LEGO_EV3_UART_33_IR_REM_A,
	LEGO_EV3_UART_33_IR_S_ALT,
	LEGO_EV3_UART_33_IR_CAL,

	WEDO_HUB_HUB,

	WEDO_MOTION_PROX,
	WEDO_MOTION_RAW,

	WEDO_TILT_TILT,
	WEDO_TILT_TILT_AXIS,
	WEDO_TILT_RAW,

	LEGO_POWER_STORAGE_IN_VOLT,
	LEGO_POWER_STORAGE_IN_AMP,
	LEGO_POWER_STORAGE_OUT_VOLT,
	LEGO_POWER_STORAGE_OUT_AMP,
	LEGO_POWER_STORAGE_JOULE,
	LEGO_POWER_STORAGE_IN_WATT,
	LEGO_POWER_STORAGE_OUT_WATT,
	LEGO_POWER_STORAGE_ALL,

	LEGO_NXT_TOUCH_TOUCH,

	LEGO_NXT_LIGHT_REFLECT,
	LEGO_NXT_LIGHT_AMBIENT,

	LEGO_NXT_SOUND_DB,
	LEGO_NXT_SOUND_DBA,

	LEGO_NXT_US_US_DIST_CM,
	LEGO_NXT_US_US_DIST_IN,
	LEGO_NXT_US_US_SI_CM,
	LEGO_NXT_US_US_SI_IN,
	LEGO_NXT_US_US_LISTEN,

	MI_XG1300L_ANGLE,
	MI_XG1300L_SPEED,
	MI_XG1300L_ACCEL,
	MI_XG1300L_ALL,

	MS_ABSOLUTE_IMU_TILT,
	MS_ABSOLUTE_IMU_ACCEL,
	MS_ABSOLUTE_IMU_COMPASS,
	MS_ABSOLUTE_IMU_MAG,
	MS_ABSOLUTE_IMU_GYRO,
	MS_ABSOLUTE_IMU_ALL,

	MS_ANGLE_ANGLE,
	MS_ANGLE_ANGLE2,
	MS_ANGLE_SPEED,
	MS_ANGLE_ALL,

	MS_EV3_SMUX_MUX,

	MS_LIGHT_ARRAY_CAL,
	MS_LIGHT_ARRAY_RAW,

	MS_LINE_LEADER_PID,
	MS_LINE_LEADER_PID_ALL,
	MS_LINE_LEADER_CAL,
	MS_LINE_LEADER_RAW,

	MS_8CH_SERVO_V3,
	MS_8CH_SERVO_OLD,

	MS_NXT_TOUCH_MUX_TOUCH_MUX,

	SENSOR_MODE__COUNT_,  /**< Count of sensor modes. */
	SENSOR_MODE__UNKNOWN_ = SENSOR_MODE__COUNT_
};

/**
 *  \brief Identifiers of sensor commands.
 */
enum {
	SENSOR_COMMAND__NONE_ = 0,

	HT_NXT_ANGLE_RESET,

	HT_NXT_SMUX_HALT,
	HT_NXT_SMUX_DETECT,
	HT_NXT_SMUX_RUN,

	WEDO_HUB_OUT_OFF,
	WEDO_HUB_OUT_ON,
	WEDO_HUB_CLEAR_ERR,

	MI_XG1300L_RESET,
	MI_XG1300L_ACCEL_2G,
	MI_XG1300L_ACCEL_4G,
	MI_XG1300L_ACCEL_8G,

	MS_ABSOLUTE_IMU_BEGIN_COMP_CAL,
	MS_ABSOLUTE_IMU_END_COMP_CAL,
	MS_ABSOLUTE_IMU_ACCEL_2G,
	MS_ABSOLUTE_IMU_ACCEL_4G,
	MS_ABSOLUTE_IMU_ACCEL_8G,
	MS_ABSOLUTE_IMU_ACCEL_16G,

	MS_ANGLE_RESET,

	MS_LIGHT_ARRAY_CAL_WHITE,
	MS_LIGHT_ARRAY_CAL_BLACK,
	MS_LIGHT_ARRAY_SLEEP,
	MS_LIGHT_ARRAY_WAKE,
	MS_LIGHT_ARRAY_60HZ,
	MS_LIGHT_ARRAY_50HZ,
	MS_LIGHT_ARRAY_UNIVERSAL,

	MS_LINE_LEADER_CAL_WHITE,
	MS_LINE_LEADER_CAL_BLACK,
	MS_LINE_LEADER_SLEEP,
	MS_LINE_LEADER_WAKE,
	MS_LINE_LEADER_INV_COL,
	MS_LINE_LEADER_RST_COL,
	MS_LINE_LEADER_SNAP,
	MS_LINE_LEADER_60HZ,
	MS_LINE_LEADER_50HZ,
	MS_LINE_LEADER_UNIVERSAL,

	SENSOR_COMMAND__COUNT_,  /**< Count of sensor commands. */
	SENSOR_COMMAND__UNKNOWN_ = SENSOR_COMMAND__COUNT_
};

/**
 *  \brief Get "address" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_address( uint8_t sn, byte *buf );

/**
 *  \brief Get "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz );

/**
 *  \brief Set "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz );

/**
 *  \brief Get "bin_data_format" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command( uint8_t sn, char *value );

/**
 *  \brief Get "commands" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "decimals" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_decimals( uint8_t sn, dword *buf );

/**
 *  \brief Get "driver_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "fw_version" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode( uint8_t sn, char *value );

/**
 *  \brief Get "modes" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "num_values" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_num_values( uint8_t sn, dword *buf );

/**
 *  \brief Get "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_poll_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_poll_ms( uint8_t sn, dword value );

/**
 *  \brief Get "port_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "units" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_units( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "value0" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value0( uint8_t sn, float *buf );

/**
 *  \brief Get "value1" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value1( uint8_t sn, float *buf );

/**
 *  \brief Get "value2" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value2( uint8_t sn, float *buf );

/**
 *  \brief Get "value3" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value3( uint8_t sn, float *buf );

/**
 *  \brief Get "value4" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value4( uint8_t sn, float *buf );

/**
 *  \brief Get "value5" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value5( uint8_t sn, float *buf );

/**
 *  \brief Get "value6" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value6( uint8_t sn, float *buf );

/**
 *  \brief Get "value7" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value7( uint8_t sn, float *buf );

/**
 *  \brief Get "value" attribute of the sensor.
 *  \param inx Attribute index.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
	 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf );

/**
 *  \brief Get name of the specified sensor type.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern const char *ev3_sensor_type( uint8_t type_inx );

/**
 *  \brief Get index of the sensor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_sensor_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the sensor.
 *  \param sn Sequence number.
 *  \param port_type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_sensor_port_inx( uint8_t sn, uint8_t port_type_inx, uint8_t *extport );

/**
 *  \brief Get descriptor of the sensor.
 *  \param sn Sequence number.
 *  \return Pointer to the sensor descriptor.
 */
extern EV3_SENSOR *ev3_sensor_desc( uint8_t sn );

/**
 *  \brief Get type from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_extport( uint8_t sn );
/**
 *  \brief Get address from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_addr( uint8_t sn );

/**
 *  \brief Search of a sequence number of the specified sensor type.
 *  \param type_inx The sensor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the sensor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param addr Address.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t addr, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified sensor mode.
 *  \param mode_inx Index of the sensor mode.
 *  \return Requested value.
 */
extern const char *ev3_sensor_mode( uint8_t mode_inx );

/**
 *  \brief Get index of the sensor mode.
 *  \param sn Sequence number.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern uint8_t get_sensor_mode_inx( uint8_t sn, uint8_t type_inx );

/**
 *  \brief Set mode of the sensor by index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the sensor mode.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode_inx( uint8_t sn, uint8_t mode_inx );

/**
 *  \brief Get name of the specified sensor command.
 *  \param command_inx Index of the sensor command.
 *  \return Requested value.
 */
extern const char *ev3_sensor_command( uint8_t command_inx );

/**
 *  \brief Set command of the sensor by index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the sensor command.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command_inx( uint8_t sn, uint8_t command_inx );

/**
 *  \brief Detect connected sensors.
 *  \return The number of found sensors or -1 in case of an error.
 */
extern int ev3_sensor_init( void );

#define TACHO_DIR  "/sys/class/tacho-motor"  /**< Directory of tachos. */

/**
 *  \brief Structure of a tacho descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Tacho type. */
	uint8_t port;  /**< Tacho EV3 port. */
	uint8_t extport;  /**< Tacho extended port. */

} EV3_TACHO;

#define TACHO_DESC__LIMIT_  64  /**< Limit of tacho descriptors. */

#define TACHO__NONE_  TACHO_DESC__LIMIT_  /**< Tacho is not found. */

/**
 *  \brief Vector of tacho descriptors (filled by \ref ev3_tacho_init).
 */
extern EV3_TACHO ev3_tacho[ TACHO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of tacho types.
 */
enum {
	TACHO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	TACHO,
	MINITACHO,

	TACHO_TYPE__COUNT_,  /**< Count of tacho types. */
	TACHO_TYPE__UNKNOWN_ = TACHO_TYPE__COUNT_
};

/**
 *  \brief Get "duty_cycle" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Get "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Get "encoder_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_encoder_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "encoder_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_encoder_mode( uint8_t sn, char *value );

/**
 *  \brief Get "encoder_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_encoder_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "estop" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_estop( uint8_t sn, int *buf );

/**
 *  \brief Set "estop" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_estop( uint8_t sn, int value );

/**
 *  \brief Get "log" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_log( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "polarity_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_polarity_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "polarity_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_polarity_mode( uint8_t sn, char *value );

/**
 *  \brief Get "polarity_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_polarity_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "port_name" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position( uint8_t sn, int *buf );

/**
 *  \brief Set "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position( uint8_t sn, int value );

/**
 *  \brief Get "position_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "position_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_mode( uint8_t sn, char *value );

/**
 *  \brief Get "position_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_sp( uint8_t sn, int value );

/**
 *  \brief Get "pulses_per_second" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_pulses_per_second( uint8_t sn, int *buf );

/**
 *  \brief Get "pulses_per_second_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_pulses_per_second_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "pulses_per_second_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_pulses_per_second_sp( uint8_t sn, int value );

/**
 *  \brief Get "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_down_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_down_sp( uint8_t sn, dword value );

/**
 *  \brief Get "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_up_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_up_sp( uint8_t sn, dword value );

/**
 *  \brief Get "regulation_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_regulation_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "regulation_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_regulation_mode( uint8_t sn, char *value );

/**
 *  \brief Get "regulation_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_regulation_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "regulation_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_regulation_modes( uint8_t sn, char *value );

/**
 *  \brief Set "reset" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_reset( uint8_t sn, bool value );

/**
 *  \brief Get "run" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_run( uint8_t sn, bool *buf );

/**
 *  \brief Set "run" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_run( uint8_t sn, bool value );

/**
 *  \brief Get "run_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_run_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "run_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_run_mode( uint8_t sn, char *value );

/**
 *  \brief Get "run_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_run_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "speed_regulation_D" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_D( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_D" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_D( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_I" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_I( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_I" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_I( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_K" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_K( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_K" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_K( uint8_t sn, int value );

/**
 *  \brief Get "speed_regulation_P" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation_P( uint8_t sn, int *buf );

/**
 *  \brief Set "speed_regulation_P" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation_P( uint8_t sn, int value );

/**
 *  \brief Get "state" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "stop_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "stop_mode" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_mode( uint8_t sn, char *value );

/**
 *  \brief Get "stop_modes" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_time_sp( uint8_t sn, dword *buf );

/**
 *  \brief Set "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_time_sp( uint8_t sn, dword value );

/**
 *  \brief Get "type" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_type( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified tacho type.
 *  \param type_inx Index of the tacho type.
 *  \return Requested value.
 */
extern const char *ev3_tacho_type( uint8_t type_inx );

/**
 *  \brief Get index of the tacho type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_tacho_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the tacho.
 *  \param sn Sequence number.
 *  \param port_type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_tacho_port_inx( uint8_t sn, uint8_t port_type_inx, uint8_t *extport );

/**
 *  \brief Get descriptor of the tacho.
 *  \param sn Sequence number.
 *  \return Pointer to the tacho descriptor.
 */
extern EV3_TACHO *ev3_tacho_desc( uint8_t sn );

/**
 *  \brief Get type from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_extport( uint8_t sn );

/**
 *  \brief Search of a sequence number of the specified tacho type.
 *  \param type_inx The tacho type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the tacho by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Detect connected tachos.
 *  \return The number of found tachos or -1 in case of an error.
 */
extern int ev3_tacho_init( void );

#define DC_DIR  "/sys/class/dc-motor"  /**< Directory of DC motors. */

/**
 *  \brief Structure of a DC motor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< DC motor type. */
	uint8_t port;  /**< DC motor EV3 port. */
	uint8_t extport;  /**< DC motor extended port. */

} EV3_DC;

#define DC_DESC__LIMIT_  64  /**< Limit of DC motor descriptors. */

#define DC__NONE_  DC_DESC__LIMIT_  /**< DC motor is not found. */

/**
 *  \brief Vector of DC motor descriptors (filled by \ref ev3_dc_init).
 */
extern EV3_DC ev3_dc[ DC_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of DC motor types.
 */
enum {
	DC_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	RCX_MOTOR,

	DC_TYPE__COUNT_,  /**< Count of DC motor types. */
	DC_TYPE__UNKNOWN_ = DC_TYPE__COUNT_
};

/**
 *  \brief Identifiers of DC motor commands.
 */
enum {
	DC_COMMAND__NONE_ = 0,

	RCX_MOTOR_RUN,
	RCX_MOTOR_BRAKE,
	RCX_MOTOR_COAST,

	DC_COMMAND__COUNT_,  /**< Count of DC motor commands. */
	DC_COMMAND__UNKNOWN_ = DC_COMMAND__COUNT_
};

/**
 *  \brief Get "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_command( uint8_t sn, char *value );

/**
 *  \brief Get "commands" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "driver_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "duty_cycle" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Get "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Set "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Get "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_polarity( uint8_t sn, char *value );

/**
 *  \brief Get "port_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "ramp_down_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_down_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_down_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_down_ms( uint8_t sn, dword value );

/**
 *  \brief Get "ramp_up_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_up_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "ramp_up_ms" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_up_ms( uint8_t sn, dword value );

/**
 *  \brief Get name of the specified DC motor type.
 *  \param type_inx Index of the DC motor type.
 *  \return Requested value.
 */
extern const char *ev3_dc_type( uint8_t type_inx );

/**
 *  \brief Get index of the DC motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_dc_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the DC motor.
 *  \param sn Sequence number.
 *  \param port_type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_dc_port_inx( uint8_t sn, uint8_t port_type_inx, uint8_t *extport );

/**
 *  \brief Get descriptor of the DC motor.
 *  \param sn Sequence number.
 *  \return Pointer to the DC motor descriptor.
 */
extern EV3_DC *ev3_dc_desc( uint8_t sn );

/**
 *  \brief Get type from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_extport( uint8_t sn );

/**
 *  \brief Search of a sequence number of the specified DC motor type.
 *  \param type_inx The DC motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the DC motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified DC motor command.
 *  \param command_inx Index of the DC motor command.
 *  \return Requested value.
 */
extern const char *ev3_dc_command( uint8_t command_inx );

/**
 *  \brief Get index of the DC motor command.
 *  \param sn Sequence number.
 *  \param type_inx Index of the DC motor type.
 *  \return Requested value.
 */
extern uint8_t get_dc_command_inx( uint8_t sn, uint8_t type_inx );

/**
 *  \brief Set command of the DC motor by index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the DC motor command.
 *  \return Count of written bytes.
 */
extern size_t set_dc_command_inx( uint8_t sn, uint8_t command_inx );

/**
 *  \brief Detect connected DC motors.
 *  \return The number of found DC motors or -1 in case of an error.
 */
extern int ev3_dc_init( void );

#define SERVO_DIR  "/sys/class/servo-motor"  /**< Directory of servo motors. */

/**
 *  \brief Structure of a servo motor descriptor.
 */
typedef struct {
	uint8_t type_inx;  /**< Servo motor type. */
	uint8_t port;  /**< Servo motor EV3 port. */
	uint8_t extport;  /**< Servo motor extended port. */
	uint8_t addr;  /**< Servo motor channel. */

} EV3_SERVO;

#define SERVO_DESC__LIMIT_  64  /**< Limit of servo motor descriptors. */

#define SERVO__NONE_  SERVO_DESC__LIMIT_  /**< Servo motor is not found. */

/**
 *  \brief Vector of servo motor descriptors (filled by \ref ev3_servo_init).
 */
extern EV3_SERVO ev3_servo[ SERVO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of servo motor types.
 */
enum {
	SERVO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	SERVO_MOTOR,

	SERVO_TYPE__COUNT_,  /**< Count of servo motor types. */
	SERVO_TYPE__UNKNOWN_ = SERVO_TYPE__COUNT_
};

/**
 *  \brief Identifiers of servo motor commands.
 */
enum {
	SERVO_COMMAND__NONE_ = 0,

	SERVO_MOTOR_RUN,
	SERVO_MOTOR_FLOAT,

	SERVO_COMMAND__COUNT_,  /**< Count of servo motor commands. */
	SERVO_COMMAND__UNKNOWN_ = SERVO_COMMAND__COUNT_
};

/**
 *  \brief Get "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_command( uint8_t sn, char *value );

/**
 *  \brief Get "driver_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "max_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_max_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "max_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_max_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "mid_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_mid_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "mid_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_mid_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "min_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_min_pulse_ms( uint8_t sn, dword *buf );

/**
 *  \brief Set "min_pulse_ms" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_min_pulse_ms( uint8_t sn, dword value );

/**
 *  \brief Get "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Set "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_polarity( uint8_t sn, char *value );

/**
 *  \brief Get "port_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get "position" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_position( uint8_t sn, int *buf );

/**
 *  \brief Set "position" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_position( uint8_t sn, int value );

/**
 *  \brief Get "rate" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_rate( uint8_t sn, dword *buf );

/**
 *  \brief Set "rate" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_rate( uint8_t sn, dword value );

/**
 *  \brief Get name of the specified servo motor type.
 *  \param type_inx Index of the servo motor type.
 *  \return Requested value.
 */
extern const char *ev3_servo_type( uint8_t type_inx );

/**
 *  \brief Get index of the servo motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t get_servo_type_inx( uint8_t sn );

/**
 *  \brief Get indexes of the EV3 port and the extended port of the servo motor.
 *  \param sn Sequence number.
 *  \param port_type_inx Port type.
 *  \param extport Buffer for the extended port index.
 *  \return EV3 port index.
 */
extern uint8_t get_servo_port_inx( uint8_t sn, uint8_t port_type_inx, uint8_t *extport );

/**
 *  \brief Get descriptor of the servo motor.
 *  \param sn Sequence number.
 *  \return Pointer to the servo motor descriptor.
 */
extern EV3_SERVO *ev3_servo_desc( uint8_t sn );

/**
 *  \brief Get type from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_type_inx( uint8_t sn );
/**
 *  \brief Get EV3 port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_port( uint8_t sn );
/**
 *  \brief Get extended port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_extport( uint8_t sn );
/**
 *  \brief Get channel from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_addr( uint8_t sn );

/**
 *  \brief Search of a sequence number of the specified servo motor type.
 *  \param type_inx The servo motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo( uint8_t type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the servo motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param addr Address.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo_plugged_in( uint8_t port, uint8_t extport, uint8_t addr, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified servo motor command.
 *  \param command_inx Index of the servo motor command.
 *  \return Requested value.
 */
extern const char *ev3_servo_command( uint8_t command_inx );

/**
 *  \brief Get index of the servo motor command.
 *  \param sn Sequence number.
 *  \param type_inx Index of the servo motor type.
 *  \return Requested value.
 */
extern uint8_t get_servo_command_inx( uint8_t sn, uint8_t type_inx );

/**
 *  \brief Set command of the servo motor by index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the servo motor command.
 *  \return Count of written bytes.
 */
extern size_t set_servo_command_inx( uint8_t sn, uint8_t command_inx );

/**
 *  \brief Detect connected servo motors.
 *  \return The number of found servo motors or -1 in case of an error.
 */
extern int ev3_servo_init( void );

/**
 *  \brief Get the channel of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Count of read bytes.
 */
extern size_t get_servo_address( uint8_t sn, uint8_t *buf );

/**
 *  \brief Get name of the specified servo motor port.
 *  \param port Port index.
 *  \param extport Extended port index.
 *  \param addr Servo motor channel.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 */
extern void ev3_servo_port_name( uint8_t port, uint8_t extport, uint8_t addr, char *buf, size_t sz );

